(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global['developer-gateway'] = {})));
}(this, (function (exports) { 'use strict';

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var cbor = createCommonjsModule(function (module) {
  /*
   * The MIT License (MIT)
   *
   * Copyright (c) 2014 Patrick Gansterer <paroga@paroga.com>
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */

  (function(global, undefined) {var POW_2_24 = Math.pow(2, -24),
      POW_2_32 = Math.pow(2, 32),
      POW_2_53 = Math.pow(2, 53);

  function encode(value) {
    var data = new ArrayBuffer(256);
    var dataView = new DataView(data);
    var lastLength;
    var offset = 0;

    function ensureSpace(length) {
      var newByteLength = data.byteLength;
      var requiredLength = offset + length;
      while (newByteLength < requiredLength)
        newByteLength *= 2;
      if (newByteLength !== data.byteLength) {
        var oldDataView = dataView;
        data = new ArrayBuffer(newByteLength);
        dataView = new DataView(data);
        var uint32count = (offset + 3) >> 2;
        for (var i = 0; i < uint32count; ++i)
          dataView.setUint32(i * 4, oldDataView.getUint32(i * 4));
      }

      lastLength = length;
      return dataView;
    }
    function write() {
      offset += lastLength;
    }
    function writeFloat64(value) {
      write(ensureSpace(8).setFloat64(offset, value));
    }
    function writeUint8(value) {
      write(ensureSpace(1).setUint8(offset, value));
    }
    function writeUint8Array(value) {
      var dataView = ensureSpace(value.length);
      for (var i = 0; i < value.length; ++i)
        dataView.setUint8(offset + i, value[i]);
      write();
    }
    function writeUint16(value) {
      write(ensureSpace(2).setUint16(offset, value));
    }
    function writeUint32(value) {
      write(ensureSpace(4).setUint32(offset, value));
    }
    function writeUint64(value) {
      var low = value % POW_2_32;
      var high = (value - low) / POW_2_32;
      var dataView = ensureSpace(8);
      dataView.setUint32(offset, high);
      dataView.setUint32(offset + 4, low);
      write();
    }
    function writeTypeAndLength(type, length) {
      if (length < 24) {
        writeUint8(type << 5 | length);
      } else if (length < 0x100) {
        writeUint8(type << 5 | 24);
        writeUint8(length);
      } else if (length < 0x10000) {
        writeUint8(type << 5 | 25);
        writeUint16(length);
      } else if (length < 0x100000000) {
        writeUint8(type << 5 | 26);
        writeUint32(length);
      } else {
        writeUint8(type << 5 | 27);
        writeUint64(length);
      }
    }
    
    function encodeItem(value) {
      var i;

      if (value === false)
        return writeUint8(0xf4);
      if (value === true)
        return writeUint8(0xf5);
      if (value === null)
        return writeUint8(0xf6);
      if (value === undefined)
        return writeUint8(0xf7);
    
      switch (typeof value) {
        case "number":
          if (Math.floor(value) === value) {
            if (0 <= value && value <= POW_2_53)
              return writeTypeAndLength(0, value);
            if (-POW_2_53 <= value && value < 0)
              return writeTypeAndLength(1, -(value + 1));
          }
          writeUint8(0xfb);
          return writeFloat64(value);

        case "string":
          var utf8data = [];
          for (i = 0; i < value.length; ++i) {
            var charCode = value.charCodeAt(i);
            if (charCode < 0x80) {
              utf8data.push(charCode);
            } else if (charCode < 0x800) {
              utf8data.push(0xc0 | charCode >> 6);
              utf8data.push(0x80 | charCode & 0x3f);
            } else if (charCode < 0xd800) {
              utf8data.push(0xe0 | charCode >> 12);
              utf8data.push(0x80 | (charCode >> 6)  & 0x3f);
              utf8data.push(0x80 | charCode & 0x3f);
            } else {
              charCode = (charCode & 0x3ff) << 10;
              charCode |= value.charCodeAt(++i) & 0x3ff;
              charCode += 0x10000;

              utf8data.push(0xf0 | charCode >> 18);
              utf8data.push(0x80 | (charCode >> 12)  & 0x3f);
              utf8data.push(0x80 | (charCode >> 6)  & 0x3f);
              utf8data.push(0x80 | charCode & 0x3f);
            }
          }

          writeTypeAndLength(3, utf8data.length);
          return writeUint8Array(utf8data);

        default:
          var length;
          if (Array.isArray(value)) {
            length = value.length;
            writeTypeAndLength(4, length);
            for (i = 0; i < length; ++i)
              encodeItem(value[i]);
          } else if (value instanceof Uint8Array) {
            writeTypeAndLength(2, value.length);
            writeUint8Array(value);
          } else {
            var keys = Object.keys(value);
            length = keys.length;
            writeTypeAndLength(5, length);
            for (i = 0; i < length; ++i) {
              var key = keys[i];
              encodeItem(key);
              encodeItem(value[key]);
            }
          }
      }
    }
    
    encodeItem(value);

    if ("slice" in data)
      return data.slice(0, offset);
    
    var ret = new ArrayBuffer(offset);
    var retView = new DataView(ret);
    for (var i = 0; i < offset; ++i)
      retView.setUint8(i, dataView.getUint8(i));
    return ret;
  }

  function decode(data, tagger, simpleValue) {
    var dataView = new DataView(data);
    var offset = 0;
    
    if (typeof tagger !== "function")
      tagger = function(value) { return value; };
    if (typeof simpleValue !== "function")
      simpleValue = function() { return undefined; };

    function read(value, length) {
      offset += length;
      return value;
    }
    function readArrayBuffer(length) {
      return read(new Uint8Array(data, offset, length), length);
    }
    function readFloat16() {
      var tempArrayBuffer = new ArrayBuffer(4);
      var tempDataView = new DataView(tempArrayBuffer);
      var value = readUint16();

      var sign = value & 0x8000;
      var exponent = value & 0x7c00;
      var fraction = value & 0x03ff;
      
      if (exponent === 0x7c00)
        exponent = 0xff << 10;
      else if (exponent !== 0)
        exponent += (127 - 15) << 10;
      else if (fraction !== 0)
        return fraction * POW_2_24;
      
      tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
      return tempDataView.getFloat32(0);
    }
    function readFloat32() {
      return read(dataView.getFloat32(offset), 4);
    }
    function readFloat64() {
      return read(dataView.getFloat64(offset), 8);
    }
    function readUint8() {
      return read(dataView.getUint8(offset), 1);
    }
    function readUint16() {
      return read(dataView.getUint16(offset), 2);
    }
    function readUint32() {
      return read(dataView.getUint32(offset), 4);
    }
    function readUint64() {
      return readUint32() * POW_2_32 + readUint32();
    }
    function readBreak() {
      if (dataView.getUint8(offset) !== 0xff)
        return false;
      offset += 1;
      return true;
    }
    function readLength(additionalInformation) {
      if (additionalInformation < 24)
        return additionalInformation;
      if (additionalInformation === 24)
        return readUint8();
      if (additionalInformation === 25)
        return readUint16();
      if (additionalInformation === 26)
        return readUint32();
      if (additionalInformation === 27)
        return readUint64();
      if (additionalInformation === 31)
        return -1;
      throw "Invalid length encoding";
    }
    function readIndefiniteStringLength(majorType) {
      var initialByte = readUint8();
      if (initialByte === 0xff)
        return -1;
      var length = readLength(initialByte & 0x1f);
      if (length < 0 || (initialByte >> 5) !== majorType)
        throw "Invalid indefinite length element";
      return length;
    }

    function appendUtf16data(utf16data, length) {
      for (var i = 0; i < length; ++i) {
        var value = readUint8();
        if (value & 0x80) {
          if (value < 0xe0) {
            value = (value & 0x1f) <<  6
                  | (readUint8() & 0x3f);
            length -= 1;
          } else if (value < 0xf0) {
            value = (value & 0x0f) << 12
                  | (readUint8() & 0x3f) << 6
                  | (readUint8() & 0x3f);
            length -= 2;
          } else {
            value = (value & 0x0f) << 18
                  | (readUint8() & 0x3f) << 12
                  | (readUint8() & 0x3f) << 6
                  | (readUint8() & 0x3f);
            length -= 3;
          }
        }

        if (value < 0x10000) {
          utf16data.push(value);
        } else {
          value -= 0x10000;
          utf16data.push(0xd800 | (value >> 10));
          utf16data.push(0xdc00 | (value & 0x3ff));
        }
      }
    }

    function decodeItem() {
      var initialByte = readUint8();
      var majorType = initialByte >> 5;
      var additionalInformation = initialByte & 0x1f;
      var i;
      var length;

      if (majorType === 7) {
        switch (additionalInformation) {
          case 25:
            return readFloat16();
          case 26:
            return readFloat32();
          case 27:
            return readFloat64();
        }
      }

      length = readLength(additionalInformation);
      if (length < 0 && (majorType < 2 || 6 < majorType))
        throw "Invalid length";

      switch (majorType) {
        case 0:
          return length;
        case 1:
          return -1 - length;
        case 2:
          if (length < 0) {
            var elements = [];
            var fullArrayLength = 0;
            while ((length = readIndefiniteStringLength(majorType)) >= 0) {
              fullArrayLength += length;
              elements.push(readArrayBuffer(length));
            }
            var fullArray = new Uint8Array(fullArrayLength);
            var fullArrayOffset = 0;
            for (i = 0; i < elements.length; ++i) {
              fullArray.set(elements[i], fullArrayOffset);
              fullArrayOffset += elements[i].length;
            }
            return fullArray;
          }
          return readArrayBuffer(length);
        case 3:
          var utf16data = [];
          if (length < 0) {
            while ((length = readIndefiniteStringLength(majorType)) >= 0)
              appendUtf16data(utf16data, length);
          } else
            appendUtf16data(utf16data, length);
          return String.fromCharCode.apply(null, utf16data);
        case 4:
          var retArray;
          if (length < 0) {
            retArray = [];
            while (!readBreak())
              retArray.push(decodeItem());
          } else {
            retArray = new Array(length);
            for (i = 0; i < length; ++i)
              retArray[i] = decodeItem();
          }
          return retArray;
        case 5:
          var retObject = {};
          for (i = 0; i < length || length < 0 && !readBreak(); ++i) {
            var key = decodeItem();
            retObject[key] = decodeItem();
          }
          return retObject;
        case 6:
          return tagger(decodeItem(), length);
        case 7:
          switch (length) {
            case 20:
              return false;
            case 21:
              return true;
            case 22:
              return null;
            case 23:
              return undefined;
            default:
              return simpleValue(length);
          }
      }
    }

    var ret = decodeItem();
    if (offset !== data.byteLength)
      throw "Remaining bytes";
    return ret;
  }

  var obj = { encode: encode, decode: decode };

  if (typeof undefined === "function" && undefined.amd)
    undefined("cbor/cbor", obj);
  else if (module.exports)
    module.exports = obj;
  else if (!global.CBOR)
    global.CBOR = obj;

  })(commonjsGlobal);
  });

  /**
   * Cbor utility module to
   * 1) provide a clean import (import * as cbor from './cbor';) and
   * 2) provide a consistent Uint8Array interface, since cbor-js uses ArrayBuffers.
   */
  var cborJs = undefined;
  // Browser.
  /* tslint:disable */
  if (typeof window !== 'undefined') {
      cborJs = cbor;
  }
  // Node;
  else {
      cborJs = require('cbor-js');
  }
  var CborDecodeError = /** @class */ (function (_super) {
      __extends(CborDecodeError, _super);
      function CborDecodeError(data) {
          var params = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              params[_i - 1] = arguments[_i];
          }
          var _this = _super.apply(this, params) || this;
          _this.data = data;
          return _this;
      }
      return CborDecodeError;
  }(Error));

  /**
   * Return a Uint8Array of an ethereum hex-encoded key (EthHex)
   * @param   keystring is the EthHex encoding of the value
   * @param   littleEndian is true if the keystring should be interpreted as
   *          little endian. Otherwise, defaults to big endian.
   * @returns the byte incoding of the value
   */
  function parseHex(keystring, littleEndian) {
      if (littleEndian === void 0) { littleEndian = false; }
      if (keystring.indexOf('0x') === 0) {
          keystring = keystring.substr(2);
      }
      if (keystring.length % 2 === 1) {
          keystring = '0' + keystring;
      }
      var key = keystring.match(/.{2}/g);
      if (key === null) {
          return new Uint8Array();
      }
      if (littleEndian) {
          key = key.reverse();
      }
      return new Uint8Array(key.map(function (byte) { return parseInt(byte, 16); }));
  }
  /**
   * Returns an ethereum hex-encoded key of a Uint8Array
   * @param {Uint8Array} keybytes
   * @returns {String} The EthHex encoding
   */
  function toHex(keybytes) {
      return keybytes.reduce(function (str, byte) { return str + byte.toString(16).padStart(2, '0'); }, '0x');
  }
  /**
   * @returns a Uint8Array representation of number with numBytes.
   * @param   num is the number of which we want a byte representation.
   * @param   numBytes is the number of bytes to have in the resultant array.
   * @param   littleEndian is true iff the resultant byte array is little Endian.
   * @throws  if the resultant array will be longer than numBytes or the given
   *          `num` is less than 0.
   */
  function parseNumber(num, numBytes, littleEndian) {
      if (littleEndian === void 0) { littleEndian = false; }
      if (num < 0) {
          throw new Error(num + " must be greater than or equal to 0");
      }
      var numberHexStr = num.toString(16);
      if (numberHexStr.length > numBytes) {
          throw new Error("cannot parse " + num + " into a byte array of length " + numBytes);
      }
      numberHexStr = '0'.repeat(numBytes * 2 - numberHexStr.length) + numberHexStr;
      return parseHex(numberHexStr, littleEndian);
  }
  /**
   * @returns a newly allocated Uint8Array of all arrays concatenated together.
   */
  function concat(arrays) {
      var size = 0;
      arrays.forEach(function (a) { return (size += a.length); });
      var concatenated = new Uint8Array(size);
      var start = 0;
      arrays.forEach(function (a) {
          concatenated.set(a, start);
          start += a.length;
      });
      return concatenated;
  }
  /**
   * decodeUtf8 is a string decoding utility for both node and browsers.
   */
  function decodeUtf8(array) {
      var decoder = 
      // tslint:disable-next-line
      typeof TextDecoder === 'undefined'
          ? // @ts-ignore
              new (require('util')).TextDecoder('utf-8') // Node.
          : new TextDecoder('utf-8'); // Browser.
      // @ts-ignore
      return decoder.decode(array);
  }
  /**
   * encodeUtf8 is a string encoding utility for both node and browsers.
   */
  function encodeUtf8(input) {
      var encoder = 
      // tslint:disable-next-line
      typeof TextEncoder === 'undefined'
          ? // @ts-ignore
              new (require('util')).TextEncoder('utf-8') // Node.
          : new TextEncoder(); // Browser.
      // @ts-ignore
      return encoder.encode(input);
  }
  /**
   * Converts the given byte array to a number. Cannot parse a number
   * larger than u64, specifically, 2**53-1 (javascripts max number).
   */
  function toNumber(bytes, le) {
      if (le === void 0) { le = false; }
      if (bytes.length > 8) {
          throw new Error('Cannot parse a number greater than u64');
      }
      var b = toHex(bytes).substr(2);
      if (le) {
          var match = b.match(/../g);
          if (match !== null) {
              b = match.reverse().join('');
          }
      }
      var result = parseInt(b, 16);
      if (result >= Number.MAX_SAFE_INTEGER) {
          throw new Error("Overflowed when converting to number: " + bytes);
      }
      return result;
  }
  /**
   * @returns the given bytes as a Uint8Array.
   * @throws  if the given bytes is not of the given `length`.
   */
  function assertLength(bytes, length) {
      if (typeof bytes === 'string') {
          bytes = parseHex(bytes);
      }
      if (bytes.length !== length) {
          throw new InvalidBytesError(bytes, "invalid bytes length: received " + bytes.length + " but expected " + length);
      }
      return bytes;
  }
  var InvalidBytesError = /** @class */ (function (_super) {
      __extends(InvalidBytesError, _super);
      function InvalidBytesError(bytes) {
          var params = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              params[_i - 1] = arguments[_i];
          }
          var _this = _super.apply(this, params) || this;
          _this.bytes = bytes;
          return _this;
      }
      return InvalidBytesError;
  }(Error));

  var bytes = /*#__PURE__*/Object.freeze({
      parseHex: parseHex,
      toHex: toHex,
      parseNumber: parseNumber,
      concat: concat,
      decodeUtf8: decodeUtf8,
      encodeUtf8: encodeUtf8,
      toNumber: toNumber,
      assertLength: assertLength,
      InvalidBytesError: InvalidBytesError
  });

  // Returns a `DefTy` object to be used for testing. See idls/test-contract.ts.
  function defType() {
      return {
          f1: 1,
          f3: {
              test: 0,
          },
          f4: [
              bytes.parseHex('0000000000000000000000000000000000000000000000000000000000000001'),
              bytes.parseHex('0000000000000000000000000000000000000000000000000000000000000002'),
              bytes.parseHex('0000000000000000000000000000000000000003'),
          ],
      };
  }

  var idl = {
      name: 'TestService',
      namespace: 'test_idl_gen',
      imports: [
          {
              name: 'testlib',
              version: '0.1.0',
          },
      ],
      type_defs: [
          {
              type: 'enum',
              name: 'InnerTy',
              variants: ['Field1', 'Field2'],
          },
          {
              type: 'event',
              name: 'TestEvent',
              fields: [
                  {
                      name: 'indexed',
                      type: {
                          type: 'defined',
                          params: {
                              type: 'DefTy',
                          },
                      },
                      indexed: true,
                  },
                  {
                      name: 'non_indexed',
                      type: {
                          type: 'tuple',
                          params: [
                              {
                                  type: 'u32',
                              },
                              {
                                  type: 'u32',
                              },
                          ],
                      },
                  },
              ],
          },
          {
              type: 'struct',
              name: 'DefTy',
              fields: [
                  {
                      name: 'f1',
                      type: {
                          type: 'optional',
                          params: {
                              type: 'i64',
                          },
                      },
                  },
                  {
                      name: 'f2',
                      type: {
                          type: 'list',
                          params: {
                              type: 'optional',
                              params: {
                                  type: 'defined',
                                  params: {
                                      type: 'DefTy',
                                  },
                              },
                          },
                      },
                  },
                  {
                      name: 'f3',
                      type: {
                          type: 'map',
                          params: [
                              {
                                  type: 'string',
                              },
                              {
                                  type: 'defined',
                                  params: {
                                      type: 'InnerTy',
                                  },
                              },
                          ],
                      },
                  },
                  {
                      name: 'f4',
                      type: {
                          type: 'tuple',
                          params: [
                              {
                                  type: 'h256',
                              },
                              {
                                  type: 'u256',
                              },
                              {
                                  type: 'address',
                              },
                          ],
                      },
                  },
              ],
          },
          {
              type: 'event',
              name: 'TestEvent2',
              fields: [
                  {
                      name: 'indexed1',
                      type: {
                          type: 'u32',
                      },
                      indexed: true,
                  },
                  {
                      name: 'indexed2',
                      type: {
                          type: 'u32',
                      },
                      indexed: true,
                  },
              ],
          },
      ],
      constructor: {
          inputs: [
              {
                  type: 'string',
              },
          ],
      },
      functions: [
          {
              name: 'the',
              mutability: 'immutable',
              inputs: [
                  {
                      type: 'list',
                      params: {
                          type: 'defined',
                          params: {
                              type: 'DefTy',
                          },
                      },
                  },
                  {
                      type: 'bytes',
                  },
              ],
              output: {
                  type: 'set',
                  params: {
                      type: 'address',
                  },
              },
          },
          {
              name: 'it',
              mutability: 'mutable',
              inputs: [
                  {
                      type: 'map',
                      params: [
                          {
                              type: 'bool',
                          },
                          {
                              type: 'array',
                              params: [
                                  {
                                      type: 'u32',
                                  },
                                  12,
                              ],
                          },
                      ],
                  },
                  {
                      type: 'set',
                      params: {
                          type: 'i64',
                      },
                  },
              ],
          },
          {
              name: 'void',
              mutability: 'immutable',
              inputs: [],
          },
          {
              name: 'import',
              mutability: 'mutable',
              inputs: [
                  {
                      type: 'defined',
                      params: {
                          namespace: 'testlib',
                          type: 'RpcType',
                      },
                  },
              ],
              output: {
                  type: 'tuple',
                  params: [
                      {
                          type: 'bool',
                      },
                      {
                          type: 'i8',
                      },
                  ],
              },
          },
      ],
      idl_gen_version: '0.1.0',
  };

  var abi = [
      {
          anonymous: false,
          inputs: [
              {
                  indexed: false,
                  name: 'newCounter',
                  type: 'uint256',
              },
          ],
          name: 'Incremented',
          type: 'event',
      },
      {
          constant: false,
          inputs: [
              {
                  name: 'value',
                  type: 'uint256',
              },
          ],
          name: 'verifyCounterValue',
          outputs: [],
          payable: false,
          stateMutability: 'nonpayable',
          type: 'function',
      },
      {
          constant: true,
          inputs: [],
          name: 'getCounter',
          outputs: [
              {
                  name: '',
                  type: 'uint256',
              },
          ],
          payable: false,
          stateMutability: 'view',
          type: 'function',
      },
      {
          constant: false,
          inputs: [],
          name: 'incrementCounter',
          outputs: [],
          payable: false,
          stateMutability: 'nonpayable',
          type: 'function',
      },
      {
          constant: false,
          inputs: [],
          name: 'incrementAndGetCounter',
          outputs: [
              {
                  name: '',
                  type: 'uint256',
              },
          ],
          payable: false,
          stateMutability: 'nonpayable',
          type: 'function',
      },
      {
          constant: false,
          inputs: [
              {
                  name: 'count',
                  type: 'uint256',
              },
          ],
          name: 'incrementCounterManyTimes',
          outputs: [],
          payable: false,
          stateMutability: 'nonpayable',
          type: 'function',
      },
  ];
  var bytecode = '0x608060405234801561001057600080fd5b506102f9806100206000396000f3fe60806040526004361061006d576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680635b34b966146100725780635caf51da146100895780637531dafc146100c45780638ada066e146100ff578063c847beca1461012a575b600080fd5b34801561007e57600080fd5b50610087610155565b005b34801561009557600080fd5b506100c2600480360360208110156100ac57600080fd5b81019080803590602001909291905050506101a0565b005b3480156100d057600080fd5b506100fd600480360360208110156100e757600080fd5b8101908080359060200190929190505050610242565b005b34801561010b57600080fd5b506101146102aa565b6040518082815260200191505060405180910390f35b34801561013657600080fd5b5061013f6102b3565b6040518082815260200191505060405180910390f35b600160008082825401925050819055507f20d8a6f5a693f9d1d627a598e8820f7a55ee74c183aa8f1a30e8d4e8dd9a8d846000546040518082815260200191505060405180910390a1565b6000548114151561023f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260288152602001807f636f756e74657220646f6573206e6f7420657175616c20746f2065787065637481526020017f65642076616c756500000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b50565b60008090505b818110156102a657600160008082825401925050819055507f20d8a6f5a693f9d1d627a598e8820f7a55ee74c183aa8f1a30e8d4e8dd9a8d846000546040518082815260200191505060405180910390a18080600101915050610248565b5050565b60008054905090565b60006001600080828254019250508190555060005490509056fea165627a7a72305820a27620d56b323564bd95d25c7b9ce214b1735bf84277dcc163f541970a4357030029';

  exports.defType = defType;
  exports.idl = idl;
  exports.abi = abi;
  exports.bytecode = bytecode;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
