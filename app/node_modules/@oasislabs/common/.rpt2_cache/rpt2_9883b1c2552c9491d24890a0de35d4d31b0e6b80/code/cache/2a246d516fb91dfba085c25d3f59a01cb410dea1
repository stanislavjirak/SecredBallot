{"map":"{\"version\":3,\"file\":\"bytes.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/bytes.ts\"],\"names\":[],\"mappings\":\";AAAA;;;;;;GAMG;AACH,MAAM,UAAU,QAAQ,CAAC,SAAiB,EAAE,YAAoB;IAApB,6BAAA,EAAA,oBAAoB;IAC9D,IAAI,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;QACjC,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;KACjC;IACD,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;QAC9B,SAAS,GAAG,GAAG,GAAG,SAAS,CAAC;KAC7B;IAED,IAAI,GAAG,GAAG,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IAEnC,IAAI,GAAG,KAAK,IAAI,EAAE;QAChB,OAAO,IAAI,UAAU,EAAE,CAAC;KACzB;IAED,IAAI,YAAY,EAAE;QAChB,GAAG,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;KACrB;IAED,OAAO,IAAI,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,EAAlB,CAAkB,CAAC,CAAC,CAAC;AAC7D,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,KAAK,CAAC,QAAoB;IACxC,OAAO,QAAQ,CAAC,MAAM,CACpB,UAAC,GAAG,EAAE,IAAI,IAAK,OAAA,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAxC,CAAwC,EACvD,IAAI,CACL,CAAC;AACJ,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,WAAW,CACzB,GAAW,EACX,QAAgB,EAChB,YAAoB;IAApB,6BAAA,EAAA,oBAAoB;IAEpB,IAAI,GAAG,GAAG,CAAC,EAAE;QACX,MAAM,IAAI,KAAK,CAAI,GAAG,wCAAqC,CAAC,CAAC;KAC9D;IACD,IAAI,YAAY,GAAG,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IACpC,IAAI,YAAY,CAAC,MAAM,GAAG,QAAQ,EAAE;QAClC,MAAM,IAAI,KAAK,CACb,kBAAgB,GAAG,qCAAgC,QAAU,CAC9D,CAAC;KACH;IAED,YAAY,GAAG,GAAG,CAAC,MAAM,CAAC,QAAQ,GAAG,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,GAAG,YAAY,CAAC;IAC7E,OAAO,QAAQ,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;AAC9C,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,MAAM,CAAC,MAAyB;IAC9C,IAAI,IAAI,GAAG,CAAC,CAAC;IACb,MAAM,CAAC,OAAO,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,EAAlB,CAAkB,CAAC,CAAC;IAExC,IAAI,YAAY,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;IAExC,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,MAAM,CAAC,OAAO,CAAC,UAAA,CAAC;QACd,YAAY,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;QAC3B,KAAK,IAAI,CAAC,CAAC,MAAM,CAAC;IACpB,CAAC,CAAC,CAAC;IAEH,OAAO,YAAY,CAAC;AACtB,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,UAAU,CAAC,KAAiB;IAC1C,IAAI,OAAO;IACT,2BAA2B;IAC3B,OAAO,WAAW,KAAK,WAAW;QAChC,CAAC,CAAC,aAAa;YACb,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,QAAQ;QACrD,CAAC,CAAC,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,WAAW;IAC3C,aAAa;IACb,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC/B,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,UAAU,CAAC,KAAa;IACtC,IAAI,OAAO;IACT,2BAA2B;IAC3B,OAAO,WAAW,KAAK,WAAW;QAChC,CAAC,CAAC,aAAa;YACb,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,QAAQ;QACrD,CAAC,CAAC,IAAI,WAAW,EAAE,CAAC,CAAC,WAAW;IACpC,aAAa;IACb,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC/B,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,QAAQ,CAAC,KAAiB,EAAE,EAAU;IAAV,mBAAA,EAAA,UAAU;IACpD,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;QACpB,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;KAC3D;IACD,IAAI,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC/B,IAAI,EAAE,EAAE;QACN,IAAI,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAC3B,IAAI,KAAK,KAAK,IAAI,EAAE;YAClB,CAAC,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SAC9B;KACF;IACD,IAAI,MAAM,GAAG,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAC7B,IAAI,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE;QACrC,MAAM,IAAI,KAAK,CAAC,2CAAyC,KAAO,CAAC,CAAC;KACnE;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,YAAY,CAC1B,KAA0B,EAC1B,MAAc;IAEd,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;KACzB;IACD,IAAI,KAAK,CAAC,MAAM,KAAK,MAAM,EAAE;QAC3B,MAAM,IAAI,iBAAiB,CACzB,KAAK,EACL,oCAAkC,KAAK,CAAC,MAAM,sBAAiB,MAAQ,CACxE,CAAC;KACH;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED;IAAuC,qCAAK;IAC1C,2BAAqB,KAAiB;QAAE,gBAAgB;aAAhB,UAAgB,EAAhB,qBAAgB,EAAhB,IAAgB;YAAhB,+BAAgB;;QAAxD,+BACW,MAAM,UAChB;QAFoB,WAAK,GAAL,KAAK,CAAY;;IAEtC,CAAC;IACH,wBAAC;AAAD,CAAC,AAJD,CAAuC,KAAK,GAI3C\"}","code":"import { __extends } from \"tslib\";\r\n/**\r\n * Return a Uint8Array of an ethereum hex-encoded key (EthHex)\r\n * @param   keystring is the EthHex encoding of the value\r\n * @param   littleEndian is true if the keystring should be interpreted as\r\n *          little endian. Otherwise, defaults to big endian.\r\n * @returns the byte incoding of the value\r\n */\r\nexport function parseHex(keystring, littleEndian) {\r\n    if (littleEndian === void 0) { littleEndian = false; }\r\n    if (keystring.indexOf('0x') === 0) {\r\n        keystring = keystring.substr(2);\r\n    }\r\n    if (keystring.length % 2 === 1) {\r\n        keystring = '0' + keystring;\r\n    }\r\n    var key = keystring.match(/.{2}/g);\r\n    if (key === null) {\r\n        return new Uint8Array();\r\n    }\r\n    if (littleEndian) {\r\n        key = key.reverse();\r\n    }\r\n    return new Uint8Array(key.map(function (byte) { return parseInt(byte, 16); }));\r\n}\r\n/**\r\n * Returns an ethereum hex-encoded key of a Uint8Array\r\n * @param {Uint8Array} keybytes\r\n * @returns {String} The EthHex encoding\r\n */\r\nexport function toHex(keybytes) {\r\n    return keybytes.reduce(function (str, byte) { return str + byte.toString(16).padStart(2, '0'); }, '0x');\r\n}\r\n/**\r\n * @returns a Uint8Array representation of number with numBytes.\r\n * @param   num is the number of which we want a byte representation.\r\n * @param   numBytes is the number of bytes to have in the resultant array.\r\n * @param   littleEndian is true iff the resultant byte array is little Endian.\r\n * @throws  if the resultant array will be longer than numBytes or the given\r\n *          `num` is less than 0.\r\n */\r\nexport function parseNumber(num, numBytes, littleEndian) {\r\n    if (littleEndian === void 0) { littleEndian = false; }\r\n    if (num < 0) {\r\n        throw new Error(num + \" must be greater than or equal to 0\");\r\n    }\r\n    var numberHexStr = num.toString(16);\r\n    if (numberHexStr.length > numBytes) {\r\n        throw new Error(\"cannot parse \" + num + \" into a byte array of length \" + numBytes);\r\n    }\r\n    numberHexStr = '0'.repeat(numBytes * 2 - numberHexStr.length) + numberHexStr;\r\n    return parseHex(numberHexStr, littleEndian);\r\n}\r\n/**\r\n * @returns a newly allocated Uint8Array of all arrays concatenated together.\r\n */\r\nexport function concat(arrays) {\r\n    var size = 0;\r\n    arrays.forEach(function (a) { return (size += a.length); });\r\n    var concatenated = new Uint8Array(size);\r\n    var start = 0;\r\n    arrays.forEach(function (a) {\r\n        concatenated.set(a, start);\r\n        start += a.length;\r\n    });\r\n    return concatenated;\r\n}\r\n/**\r\n * decodeUtf8 is a string decoding utility for both node and browsers.\r\n */\r\nexport function decodeUtf8(array) {\r\n    var decoder = \r\n    // tslint:disable-next-line\r\n    typeof TextDecoder === 'undefined'\r\n        ? // @ts-ignore\r\n            new (require('util')).TextDecoder('utf-8') // Node.\r\n        : new TextDecoder('utf-8'); // Browser.\r\n    // @ts-ignore\r\n    return decoder.decode(array);\r\n}\r\n/**\r\n * encodeUtf8 is a string encoding utility for both node and browsers.\r\n */\r\nexport function encodeUtf8(input) {\r\n    var encoder = \r\n    // tslint:disable-next-line\r\n    typeof TextEncoder === 'undefined'\r\n        ? // @ts-ignore\r\n            new (require('util')).TextEncoder('utf-8') // Node.\r\n        : new TextEncoder(); // Browser.\r\n    // @ts-ignore\r\n    return encoder.encode(input);\r\n}\r\n/**\r\n * Converts the given byte array to a number. Cannot parse a number\r\n * larger than u64, specifically, 2**53-1 (javascripts max number).\r\n */\r\nexport function toNumber(bytes, le) {\r\n    if (le === void 0) { le = false; }\r\n    if (bytes.length > 8) {\r\n        throw new Error('Cannot parse a number greater than u64');\r\n    }\r\n    var b = toHex(bytes).substr(2);\r\n    if (le) {\r\n        var match = b.match(/../g);\r\n        if (match !== null) {\r\n            b = match.reverse().join('');\r\n        }\r\n    }\r\n    var result = parseInt(b, 16);\r\n    if (result >= Number.MAX_SAFE_INTEGER) {\r\n        throw new Error(\"Overflowed when converting to number: \" + bytes);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @returns the given bytes as a Uint8Array.\r\n * @throws  if the given bytes is not of the given `length`.\r\n */\r\nexport function assertLength(bytes, length) {\r\n    if (typeof bytes === 'string') {\r\n        bytes = parseHex(bytes);\r\n    }\r\n    if (bytes.length !== length) {\r\n        throw new InvalidBytesError(bytes, \"invalid bytes length: received \" + bytes.length + \" but expected \" + length);\r\n    }\r\n    return bytes;\r\n}\r\nvar InvalidBytesError = /** @class */ (function (_super) {\r\n    __extends(InvalidBytesError, _super);\r\n    function InvalidBytesError(bytes) {\r\n        var params = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            params[_i - 1] = arguments[_i];\r\n        }\r\n        var _this = _super.apply(this, params) || this;\r\n        _this.bytes = bytes;\r\n        return _this;\r\n    }\r\n    return InvalidBytesError;\r\n}(Error));\r\nexport { InvalidBytesError };\r\n//# sourceMappingURL=bytes.js.map","dts":{"name":"/Users/armaniferrante/Documents/code/src/github.com/oasislabs/qwer/oasis.js/packages/common/dist/lib/src/bytes.d.ts","writeByteOrderMark":false,"text":"/**\r\n * Return a Uint8Array of an ethereum hex-encoded key (EthHex)\r\n * @param   keystring is the EthHex encoding of the value\r\n * @param   littleEndian is true if the keystring should be interpreted as\r\n *          little endian. Otherwise, defaults to big endian.\r\n * @returns the byte incoding of the value\r\n */\r\nexport declare function parseHex(keystring: string, littleEndian?: boolean): Uint8Array;\r\n/**\r\n * Returns an ethereum hex-encoded key of a Uint8Array\r\n * @param {Uint8Array} keybytes\r\n * @returns {String} The EthHex encoding\r\n */\r\nexport declare function toHex(keybytes: Uint8Array): string;\r\n/**\r\n * @returns a Uint8Array representation of number with numBytes.\r\n * @param   num is the number of which we want a byte representation.\r\n * @param   numBytes is the number of bytes to have in the resultant array.\r\n * @param   littleEndian is true iff the resultant byte array is little Endian.\r\n * @throws  if the resultant array will be longer than numBytes or the given\r\n *          `num` is less than 0.\r\n */\r\nexport declare function parseNumber(num: number, numBytes: number, littleEndian?: boolean): Uint8Array;\r\n/**\r\n * @returns a newly allocated Uint8Array of all arrays concatenated together.\r\n */\r\nexport declare function concat(arrays: Array<Uint8Array>): Uint8Array;\r\n/**\r\n * decodeUtf8 is a string decoding utility for both node and browsers.\r\n */\r\nexport declare function decodeUtf8(array: Uint8Array): string;\r\n/**\r\n * encodeUtf8 is a string encoding utility for both node and browsers.\r\n */\r\nexport declare function encodeUtf8(input: string): Uint8Array;\r\n/**\r\n * Converts the given byte array to a number. Cannot parse a number\r\n * larger than u64, specifically, 2**53-1 (javascripts max number).\r\n */\r\nexport declare function toNumber(bytes: Uint8Array, le?: boolean): number;\r\n/**\r\n * @returns the given bytes as a Uint8Array.\r\n * @throws  if the given bytes is not of the given `length`.\r\n */\r\nexport declare function assertLength(bytes: string | Uint8Array, length: number): Uint8Array;\r\nexport declare class InvalidBytesError extends Error {\r\n    readonly bytes: Uint8Array;\r\n    constructor(bytes: Uint8Array, ...params: any[]);\r\n}\r\n"}}
