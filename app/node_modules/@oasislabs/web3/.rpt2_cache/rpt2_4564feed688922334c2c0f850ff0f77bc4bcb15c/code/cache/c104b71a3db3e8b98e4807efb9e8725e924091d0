{"map":"{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/web3/index.ts\"],\"names\":[],\"mappings\":\";AAAA,OAAO,YAAY,MAAM,YAAY,CAAC;AACtC,OAAO,gBAAgB,MAAM,WAAW,CAAC;AAEzC;;;;;;;;;;;;;;;;;GAiBG;AACH;IAgBE,cAAqB,QAAsB;QAAtB,aAAQ,GAAR,QAAQ,CAAc;QACzC,IAAM,IAAI,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAErC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QACpB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACxB,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;IACtB,CAAC;IAED;;;;;OAKG;IACK,+BAAgB,GAAxB;QAAA,iBAUC;QATC,IAAI,aAAa,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC;QACpD,gBAAgB,CAAC,OAAO,CAAC,UAAA,GAAG;YACtB,IAAA,0BAA2C,EAA1C,iBAAS,EAAE,cAA+B,CAAC;YAC/C,aAAqB,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,GAAG;gBAAO,gBAAgB;qBAAhB,UAAgB,EAAhB,qBAAgB,EAAhB,IAAgB;oBAAhB,2BAAgB;;;;;wBAC3D,SAAS,GAAM,SAAS,SAAI,MAAQ,CAAC;wBAC3C,sBAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,MAAM,CAAC,EAAC;;;aAC9C,CAAC;QACJ,CAAC,CAAC,CAAC;QACH,OAAO,aAAa,CAAC;IACvB,CAAC;IACH,WAAC;AAAD,CAAC,AAzCD,IAyCC;;AAOD,OAAO,EAAE,YAAY,EAAE,CAAC\"}","code":"import { __awaiter, __generator } from \"tslib\";\r\nimport Web3Provider from './provider';\r\nimport WEB3_RPC_METHODS from './methods';\r\n/**\r\n * Web3 JSON RPC implementation.\r\n *\r\n * Spec: https://github.com/ethereum/wiki/wiki/JSON-RPC\r\n *\r\n * Supported namespaces:\r\n *\r\n * - `eth`\r\n * - `oasis`\r\n * - `net`\r\n *\r\n * Note that the Web3 object merely exposes the raw underlying RPC methods.\r\n * This means that the responses will be the raw results given back from the\r\n * rpc server. However, there is one exception: subscriptions, which are not\r\n * formally a part of the web3 JSON rpc spec. Here, subscriptions created\r\n * via Web3.eth.subscribe will return an event emitter that can be used to\r\n * listen for `data` events.\r\n */\r\nvar Web3 = /** @class */ (function () {\r\n    function Web3(provider) {\r\n        this.provider = provider;\r\n        var rpcs = this.generateWeb3Rpcs();\r\n        this.eth = rpcs.eth;\r\n        this.oasis = rpcs.oasis;\r\n        this.net = rpcs.net;\r\n    }\r\n    /**\r\n     * @returns an object wth all the web3 rpc methods attached.\r\n     *\r\n     * TODO: validate inputs to the web3 rpc methods. For now, just let the\r\n     *       remote gateway do the rejecting if invalid args are provided.\r\n     */\r\n    Web3.prototype.generateWeb3Rpcs = function () {\r\n        var _this = this;\r\n        var generatedRpcs = { eth: {}, oasis: {}, net: {} };\r\n        WEB3_RPC_METHODS.forEach(function (rpc) {\r\n            var _a = rpc.method.split('_'), namespace = _a[0], method = _a[1];\r\n            generatedRpcs[namespace][method] = function () {\r\n                var params = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    params[_i] = arguments[_i];\r\n                }\r\n                return __awaiter(_this, void 0, void 0, function () {\r\n                    var rpcMethod;\r\n                    return __generator(this, function (_a) {\r\n                        rpcMethod = namespace + \"_\" + method;\r\n                        return [2 /*return*/, this.provider.send(rpcMethod, params)];\r\n                    });\r\n                });\r\n            };\r\n        });\r\n        return generatedRpcs;\r\n    };\r\n    return Web3;\r\n}());\r\nexport { Web3 };\r\nexport { Web3Provider };\r\n//# sourceMappingURL=index.js.map","dts":{"name":"/Users/armaniferrante/Documents/code/src/github.com/oasislabs/tttt/oasis.js/packages/web3/dist/lib/src/web3/index.d.ts","writeByteOrderMark":false,"text":"import Web3Provider from './provider';\r\n/**\r\n * Web3 JSON RPC implementation.\r\n *\r\n * Spec: https://github.com/ethereum/wiki/wiki/JSON-RPC\r\n *\r\n * Supported namespaces:\r\n *\r\n * - `eth`\r\n * - `oasis`\r\n * - `net`\r\n *\r\n * Note that the Web3 object merely exposes the raw underlying RPC methods.\r\n * This means that the responses will be the raw results given back from the\r\n * rpc server. However, there is one exception: subscriptions, which are not\r\n * formally a part of the web3 JSON rpc spec. Here, subscriptions created\r\n * via Web3.eth.subscribe will return an event emitter that can be used to\r\n * listen for `data` events.\r\n */\r\nexport declare class Web3 {\r\n    readonly provider: Web3Provider;\r\n    /**\r\n     * `eth_*` web3 rpc methods.\r\n     */\r\n    eth: Web3Namespace;\r\n    /**\r\n     * `oasis_*` web3 rpc methods.\r\n     */\r\n    oasis: Web3Namespace;\r\n    /**\r\n     * `net_*` web3 rpc methods.\r\n     */\r\n    net: Web3Namespace;\r\n    constructor(provider: Web3Provider);\r\n    /**\r\n     * @returns an object wth all the web3 rpc methods attached.\r\n     *\r\n     * TODO: validate inputs to the web3 rpc methods. For now, just let the\r\n     *       remote gateway do the rejecting if invalid args are provided.\r\n     */\r\n    private generateWeb3Rpcs;\r\n}\r\n/**\r\n * Represents a valid web3 namespace.\r\n */\r\nexport declare type Web3Namespace = any;\r\nexport { Web3Provider };\r\n"}}
