import { EventEmitter } from 'eventemitter3';
import { JsonRpcWebSocketError } from './error';
/**
 * We internally try to handle reconnection when the websocket closes abnormally,
 * but if we encounter a bunch of errors without ever successfully opening a
 * connection, we'll forward a trouble condition to our consumer. This is the
 * number of consecutive errors after which we inform our consumer.
 */
var ERROR_FORWARD_THRESHOLD = 2;
/**
 * Time (in milliseconds) before a request sent through a JsonRpcWebSocket
 * expires.
 *
 * Some RPCs like oasis_invoke are synchronous at the gateway and so this is
 * a bit high. We should bring this down once we remove all synchrous rpcs.
 */
var REQUEST_TIMEOUT_DURATION = 30000;
var JsonRpcWebSocket = /** @class */ (function () {
    /**
     * @param url is the websocket url to connect to.
     * @param middleware is the middleware to use to process websocket messages.
     * @param wsFactory? is given as an optional WebSocketFactory implementation
     *        (for testing).
     */
    function JsonRpcWebSocket(url, middleware, wsFactory) {
        this.url = url;
        /**
         * responses implements a request-response pattern for `send` requests.
         */
        this.responses = new EventEmitter();
        /**
         * JSON rpc request id auto counter.
         */
        this.requestId = 0;
        /**
         * lifecycle emits events pertaining to the lifecycle of the websocket,
         * e.g., when it opens or closes.
         */
        this.lifecycle = new EventEmitter();
        /**
         * This counts how many websocket errors we've encountered without an `open` event.
         */
        this.consecutiveErrors = 0;
        /**
         * True iff we want to close the websocket immediately when it is opened.
         * This is set when we are asked to close the websocket in the middle of
         * establishing a connection, which we can't do; hence this hack.
         */
        this.closeOnOpen = false;
        /**
         * connectionState emits `trouble` and `ok` events.
         */
        // TODO: this should be typed to be an event emitter once we address
        //       https://github.com/oasislabs/oasis-client/issues/25
        this.connectionState = new EventEmitter();
        this.middleware = middleware;
        this.websocketFactory = wsFactory ? wsFactory : new EnvWebSocketFactory();
        this.websocket = this.websocketFactory.make(url);
        this.addEventListeners();
    }
    JsonRpcWebSocket.prototype.addEventListeners = function () {
        this.websocket.addEventListener('message', this.message.bind(this));
        this.websocket.addEventListener('open', this.open.bind(this));
        this.websocket.addEventListener('error', this.error.bind(this));
        this.websocket.addEventListener('close', this.close.bind(this));
    };
    JsonRpcWebSocket.prototype.removeEventListeners = function () {
        this.websocket.removeEventListener('message', this.message);
        this.websocket.removeEventListener('open', this.open);
        this.websocket.removeEventListener('error', this.error);
        this.websocket.removeEventListener('close', this.close);
    };
    JsonRpcWebSocket.prototype.message = function (m) {
        m = this.runMiddleware(m);
        if (!m) {
            return;
        }
        this.handler(m);
    };
    JsonRpcWebSocket.prototype.runMiddleware = function (data) {
        this.middleware.forEach(function (m) {
            data = m.handle(data);
            if (!data) {
                return undefined;
            }
        });
        return data;
    };
    JsonRpcWebSocket.prototype.handler = function (m) {
        var data = JSON.parse(m.data);
        this.responses.emit("" + data.id, data);
    };
    JsonRpcWebSocket.prototype.open = function (event) {
        this.lifecycle.emit('open');
        // We were asked to close this websocket while connecting,
        // so finish the jobn.
        if (this.closeOnOpen) {
            this.websocket.close(CloseEvent.NORMAL);
            return;
        }
        if (this.consecutiveErrors >= ERROR_FORWARD_THRESHOLD) {
            // We have notified our consumer of connection trouble, so now notify
            // them that we've reconnected.
            this.connectionState.emit('ok');
        }
        this.consecutiveErrors = 0;
    };
    JsonRpcWebSocket.prototype.error = function (event) {
        this.consecutiveErrors++;
        if (this.consecutiveErrors === ERROR_FORWARD_THRESHOLD) {
            // This is when we've crossed the threshold for forwarding the connection
            // trouble condition. Additionally, don't repeatedly notify after we've
            // already notified, until after we successfully reconnect.
            this.connectionState.emit('trouble');
        }
    };
    JsonRpcWebSocket.prototype.close = function (event) {
        this.removeEventListeners();
        if (event.code !== CloseEvent.NORMAL) {
            this.connect();
            return;
        }
    };
    JsonRpcWebSocket.prototype.connect = function () {
        // @ts-ignore
        this.websocket = this.websocketFactory.make(this.url);
        this.addEventListeners();
    };
    JsonRpcWebSocket.prototype.disconnect = function () {
        // The websocket is open so go ahead and close it.
        if (this.websocket.readyState === this.websocket.OPEN) {
            this.websocket.close(CloseEvent.NORMAL);
        }
        // The websocket is in the middle of establishing a connection.
        // We can't close a websocket if it's not open, so wait for it
        // to be open then close.
        else if (this.websocket.readyState === this.websocket.CONNECTING) {
            this.closeOnOpen = true;
        }
    };
    JsonRpcWebSocket.prototype.request = function (request) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // WebSocket is not open, so wait until it's open and try again.
            if (_this.websocket.readyState !== _this.websocket.OPEN) {
                _this.lifecycle.once('open', function () {
                    _this.request(request)
                        .then(resolve)
                        .catch(console.error);
                });
                return;
            }
            // Websocket is open so proceed.
            var id = _this.nextId();
            // Function invoked when a response event on topic `id` is emitted.
            var responseListener;
            // Set timeout for this request.
            var timeout = setTimeout(function () {
                _this.responses.removeListener(responseListener);
                var error = new JsonRpcWebSocketError(request, "request timeout " + REQUEST_TIMEOUT_DURATION + " ms have passed");
                reject(error);
            }, REQUEST_TIMEOUT_DURATION);
            responseListener = function (jsonResponse) {
                clearTimeout(timeout);
                if (jsonResponse.error) {
                    reject(jsonResponse.error);
                }
                else {
                    resolve(jsonResponse);
                }
            };
            _this.responses.once("" + id, responseListener);
            _this.websocket.send(JSON.stringify({
                id: id,
                jsonrpc: '2.0',
                method: request.method,
                params: request.params,
            }));
        });
    };
    JsonRpcWebSocket.prototype.nextId = function () {
        this.requestId += 1;
        return this.requestId - 1;
    };
    return JsonRpcWebSocket;
}());
export { JsonRpcWebSocket };
var CloseEvent;
(function (CloseEvent) {
    CloseEvent[CloseEvent["NORMAL"] = 1000] = "NORMAL";
})(CloseEvent || (CloseEvent = {}));
/**
 * Creates a WebSocket based upon whether we're in a node or browser
 * environment.
 */
var EnvWebSocketFactory = /** @class */ (function () {
    function EnvWebSocketFactory() {
    }
    EnvWebSocketFactory.prototype.make = function (url) {
        // tslint:disable-next-line
        return typeof WebSocket !== 'undefined'
            ? // Browser.
                new WebSocket(url)
            : // Node.
                new (require('ws'))(url);
    };
    return EnvWebSocketFactory;
}());
//# sourceMappingURL=websocket.js.map