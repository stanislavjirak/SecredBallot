(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.index = {})));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$1 = function(d, b) {
        extendStatics$1 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$1(d, b);
    };

    function __extends$1(d, b) {
        extendStatics$1(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var cbor = createCommonjsModule(function (module) {
    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Patrick Gansterer <paroga@paroga.com>
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */

    (function(global, undefined) {var POW_2_24 = Math.pow(2, -24),
        POW_2_32 = Math.pow(2, 32),
        POW_2_53 = Math.pow(2, 53);

    function encode(value) {
      var data = new ArrayBuffer(256);
      var dataView = new DataView(data);
      var lastLength;
      var offset = 0;

      function ensureSpace(length) {
        var newByteLength = data.byteLength;
        var requiredLength = offset + length;
        while (newByteLength < requiredLength)
          newByteLength *= 2;
        if (newByteLength !== data.byteLength) {
          var oldDataView = dataView;
          data = new ArrayBuffer(newByteLength);
          dataView = new DataView(data);
          var uint32count = (offset + 3) >> 2;
          for (var i = 0; i < uint32count; ++i)
            dataView.setUint32(i * 4, oldDataView.getUint32(i * 4));
        }

        lastLength = length;
        return dataView;
      }
      function write() {
        offset += lastLength;
      }
      function writeFloat64(value) {
        write(ensureSpace(8).setFloat64(offset, value));
      }
      function writeUint8(value) {
        write(ensureSpace(1).setUint8(offset, value));
      }
      function writeUint8Array(value) {
        var dataView = ensureSpace(value.length);
        for (var i = 0; i < value.length; ++i)
          dataView.setUint8(offset + i, value[i]);
        write();
      }
      function writeUint16(value) {
        write(ensureSpace(2).setUint16(offset, value));
      }
      function writeUint32(value) {
        write(ensureSpace(4).setUint32(offset, value));
      }
      function writeUint64(value) {
        var low = value % POW_2_32;
        var high = (value - low) / POW_2_32;
        var dataView = ensureSpace(8);
        dataView.setUint32(offset, high);
        dataView.setUint32(offset + 4, low);
        write();
      }
      function writeTypeAndLength(type, length) {
        if (length < 24) {
          writeUint8(type << 5 | length);
        } else if (length < 0x100) {
          writeUint8(type << 5 | 24);
          writeUint8(length);
        } else if (length < 0x10000) {
          writeUint8(type << 5 | 25);
          writeUint16(length);
        } else if (length < 0x100000000) {
          writeUint8(type << 5 | 26);
          writeUint32(length);
        } else {
          writeUint8(type << 5 | 27);
          writeUint64(length);
        }
      }
      
      function encodeItem(value) {
        var i;

        if (value === false)
          return writeUint8(0xf4);
        if (value === true)
          return writeUint8(0xf5);
        if (value === null)
          return writeUint8(0xf6);
        if (value === undefined)
          return writeUint8(0xf7);
      
        switch (typeof value) {
          case "number":
            if (Math.floor(value) === value) {
              if (0 <= value && value <= POW_2_53)
                return writeTypeAndLength(0, value);
              if (-POW_2_53 <= value && value < 0)
                return writeTypeAndLength(1, -(value + 1));
            }
            writeUint8(0xfb);
            return writeFloat64(value);

          case "string":
            var utf8data = [];
            for (i = 0; i < value.length; ++i) {
              var charCode = value.charCodeAt(i);
              if (charCode < 0x80) {
                utf8data.push(charCode);
              } else if (charCode < 0x800) {
                utf8data.push(0xc0 | charCode >> 6);
                utf8data.push(0x80 | charCode & 0x3f);
              } else if (charCode < 0xd800) {
                utf8data.push(0xe0 | charCode >> 12);
                utf8data.push(0x80 | (charCode >> 6)  & 0x3f);
                utf8data.push(0x80 | charCode & 0x3f);
              } else {
                charCode = (charCode & 0x3ff) << 10;
                charCode |= value.charCodeAt(++i) & 0x3ff;
                charCode += 0x10000;

                utf8data.push(0xf0 | charCode >> 18);
                utf8data.push(0x80 | (charCode >> 12)  & 0x3f);
                utf8data.push(0x80 | (charCode >> 6)  & 0x3f);
                utf8data.push(0x80 | charCode & 0x3f);
              }
            }

            writeTypeAndLength(3, utf8data.length);
            return writeUint8Array(utf8data);

          default:
            var length;
            if (Array.isArray(value)) {
              length = value.length;
              writeTypeAndLength(4, length);
              for (i = 0; i < length; ++i)
                encodeItem(value[i]);
            } else if (value instanceof Uint8Array) {
              writeTypeAndLength(2, value.length);
              writeUint8Array(value);
            } else {
              var keys = Object.keys(value);
              length = keys.length;
              writeTypeAndLength(5, length);
              for (i = 0; i < length; ++i) {
                var key = keys[i];
                encodeItem(key);
                encodeItem(value[key]);
              }
            }
        }
      }
      
      encodeItem(value);

      if ("slice" in data)
        return data.slice(0, offset);
      
      var ret = new ArrayBuffer(offset);
      var retView = new DataView(ret);
      for (var i = 0; i < offset; ++i)
        retView.setUint8(i, dataView.getUint8(i));
      return ret;
    }

    function decode(data, tagger, simpleValue) {
      var dataView = new DataView(data);
      var offset = 0;
      
      if (typeof tagger !== "function")
        tagger = function(value) { return value; };
      if (typeof simpleValue !== "function")
        simpleValue = function() { return undefined; };

      function read(value, length) {
        offset += length;
        return value;
      }
      function readArrayBuffer(length) {
        return read(new Uint8Array(data, offset, length), length);
      }
      function readFloat16() {
        var tempArrayBuffer = new ArrayBuffer(4);
        var tempDataView = new DataView(tempArrayBuffer);
        var value = readUint16();

        var sign = value & 0x8000;
        var exponent = value & 0x7c00;
        var fraction = value & 0x03ff;
        
        if (exponent === 0x7c00)
          exponent = 0xff << 10;
        else if (exponent !== 0)
          exponent += (127 - 15) << 10;
        else if (fraction !== 0)
          return fraction * POW_2_24;
        
        tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
        return tempDataView.getFloat32(0);
      }
      function readFloat32() {
        return read(dataView.getFloat32(offset), 4);
      }
      function readFloat64() {
        return read(dataView.getFloat64(offset), 8);
      }
      function readUint8() {
        return read(dataView.getUint8(offset), 1);
      }
      function readUint16() {
        return read(dataView.getUint16(offset), 2);
      }
      function readUint32() {
        return read(dataView.getUint32(offset), 4);
      }
      function readUint64() {
        return readUint32() * POW_2_32 + readUint32();
      }
      function readBreak() {
        if (dataView.getUint8(offset) !== 0xff)
          return false;
        offset += 1;
        return true;
      }
      function readLength(additionalInformation) {
        if (additionalInformation < 24)
          return additionalInformation;
        if (additionalInformation === 24)
          return readUint8();
        if (additionalInformation === 25)
          return readUint16();
        if (additionalInformation === 26)
          return readUint32();
        if (additionalInformation === 27)
          return readUint64();
        if (additionalInformation === 31)
          return -1;
        throw "Invalid length encoding";
      }
      function readIndefiniteStringLength(majorType) {
        var initialByte = readUint8();
        if (initialByte === 0xff)
          return -1;
        var length = readLength(initialByte & 0x1f);
        if (length < 0 || (initialByte >> 5) !== majorType)
          throw "Invalid indefinite length element";
        return length;
      }

      function appendUtf16data(utf16data, length) {
        for (var i = 0; i < length; ++i) {
          var value = readUint8();
          if (value & 0x80) {
            if (value < 0xe0) {
              value = (value & 0x1f) <<  6
                    | (readUint8() & 0x3f);
              length -= 1;
            } else if (value < 0xf0) {
              value = (value & 0x0f) << 12
                    | (readUint8() & 0x3f) << 6
                    | (readUint8() & 0x3f);
              length -= 2;
            } else {
              value = (value & 0x0f) << 18
                    | (readUint8() & 0x3f) << 12
                    | (readUint8() & 0x3f) << 6
                    | (readUint8() & 0x3f);
              length -= 3;
            }
          }

          if (value < 0x10000) {
            utf16data.push(value);
          } else {
            value -= 0x10000;
            utf16data.push(0xd800 | (value >> 10));
            utf16data.push(0xdc00 | (value & 0x3ff));
          }
        }
      }

      function decodeItem() {
        var initialByte = readUint8();
        var majorType = initialByte >> 5;
        var additionalInformation = initialByte & 0x1f;
        var i;
        var length;

        if (majorType === 7) {
          switch (additionalInformation) {
            case 25:
              return readFloat16();
            case 26:
              return readFloat32();
            case 27:
              return readFloat64();
          }
        }

        length = readLength(additionalInformation);
        if (length < 0 && (majorType < 2 || 6 < majorType))
          throw "Invalid length";

        switch (majorType) {
          case 0:
            return length;
          case 1:
            return -1 - length;
          case 2:
            if (length < 0) {
              var elements = [];
              var fullArrayLength = 0;
              while ((length = readIndefiniteStringLength(majorType)) >= 0) {
                fullArrayLength += length;
                elements.push(readArrayBuffer(length));
              }
              var fullArray = new Uint8Array(fullArrayLength);
              var fullArrayOffset = 0;
              for (i = 0; i < elements.length; ++i) {
                fullArray.set(elements[i], fullArrayOffset);
                fullArrayOffset += elements[i].length;
              }
              return fullArray;
            }
            return readArrayBuffer(length);
          case 3:
            var utf16data = [];
            if (length < 0) {
              while ((length = readIndefiniteStringLength(majorType)) >= 0)
                appendUtf16data(utf16data, length);
            } else
              appendUtf16data(utf16data, length);
            return String.fromCharCode.apply(null, utf16data);
          case 4:
            var retArray;
            if (length < 0) {
              retArray = [];
              while (!readBreak())
                retArray.push(decodeItem());
            } else {
              retArray = new Array(length);
              for (i = 0; i < length; ++i)
                retArray[i] = decodeItem();
            }
            return retArray;
          case 5:
            var retObject = {};
            for (i = 0; i < length || length < 0 && !readBreak(); ++i) {
              var key = decodeItem();
              retObject[key] = decodeItem();
            }
            return retObject;
          case 6:
            return tagger(decodeItem(), length);
          case 7:
            switch (length) {
              case 20:
                return false;
              case 21:
                return true;
              case 22:
                return null;
              case 23:
                return undefined;
              default:
                return simpleValue(length);
            }
        }
      }

      var ret = decodeItem();
      if (offset !== data.byteLength)
        throw "Remaining bytes";
      return ret;
    }

    var obj = { encode: encode, decode: decode };

    if (typeof undefined === "function" && undefined.amd)
      undefined("cbor/cbor", obj);
    else if (module.exports)
      module.exports = obj;
    else if (!global.CBOR)
      global.CBOR = obj;

    })(commonjsGlobal);
    });

    /**
     * Cbor utility module to
     * 1) provide a clean import (import * as cbor from './cbor';) and
     * 2) provide a consistent Uint8Array interface, since cbor-js uses ArrayBuffers.
     */
    var cborJs = undefined;
    // Browser.
    /* tslint:disable */
    if (typeof window !== 'undefined') {
        cborJs = cbor;
    }
    // Node;
    else {
        cborJs = require('cbor-js');
    }
    var CborDecodeError = /** @class */ (function (_super) {
        __extends$1(CborDecodeError, _super);
        function CborDecodeError(data) {
            var params = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                params[_i - 1] = arguments[_i];
            }
            var _this = _super.apply(this, params) || this;
            _this.data = data;
            return _this;
        }
        return CborDecodeError;
    }(Error));

    /**
     * Return a Uint8Array of an ethereum hex-encoded key (EthHex)
     * @param   keystring is the EthHex encoding of the value
     * @param   littleEndian is true if the keystring should be interpreted as
     *          little endian. Otherwise, defaults to big endian.
     * @returns the byte incoding of the value
     */
    function parseHex(keystring, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        if (keystring.indexOf('0x') === 0) {
            keystring = keystring.substr(2);
        }
        if (keystring.length % 2 === 1) {
            keystring = '0' + keystring;
        }
        var key = keystring.match(/.{2}/g);
        if (key === null) {
            return new Uint8Array();
        }
        if (littleEndian) {
            key = key.reverse();
        }
        return new Uint8Array(key.map(function (byte) { return parseInt(byte, 16); }));
    }
    /**
     * Returns an ethereum hex-encoded key of a Uint8Array
     * @param {Uint8Array} keybytes
     * @returns {String} The EthHex encoding
     */
    function toHex(keybytes) {
        return keybytes.reduce(function (str, byte) { return str + byte.toString(16).padStart(2, '0'); }, '0x');
    }
    /**
     * @returns a Uint8Array representation of number with numBytes.
     * @param   num is the number of which we want a byte representation.
     * @param   numBytes is the number of bytes to have in the resultant array.
     * @param   littleEndian is true iff the resultant byte array is little Endian.
     * @throws  if the resultant array will be longer than numBytes or the given
     *          `num` is less than 0.
     */
    function parseNumber(num, numBytes, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        if (num < 0) {
            throw new Error(num + " must be greater than or equal to 0");
        }
        var numberHexStr = num.toString(16);
        if (numberHexStr.length > numBytes) {
            throw new Error("cannot parse " + num + " into a byte array of length " + numBytes);
        }
        numberHexStr = '0'.repeat(numBytes * 2 - numberHexStr.length) + numberHexStr;
        return parseHex(numberHexStr, littleEndian);
    }
    /**
     * @returns a newly allocated Uint8Array of all arrays concatenated together.
     */
    function concat(arrays) {
        var size = 0;
        arrays.forEach(function (a) { return (size += a.length); });
        var concatenated = new Uint8Array(size);
        var start = 0;
        arrays.forEach(function (a) {
            concatenated.set(a, start);
            start += a.length;
        });
        return concatenated;
    }
    /**
     * decodeUtf8 is a string decoding utility for both node and browsers.
     */
    function decodeUtf8(array) {
        var decoder = 
        // tslint:disable-next-line
        typeof TextDecoder === 'undefined'
            ? // @ts-ignore
                new (require('util')).TextDecoder('utf-8') // Node.
            : new TextDecoder('utf-8'); // Browser.
        // @ts-ignore
        return decoder.decode(array);
    }
    /**
     * encodeUtf8 is a string encoding utility for both node and browsers.
     */
    function encodeUtf8(input) {
        var encoder = 
        // tslint:disable-next-line
        typeof TextEncoder === 'undefined'
            ? // @ts-ignore
                new (require('util')).TextEncoder('utf-8') // Node.
            : new TextEncoder(); // Browser.
        // @ts-ignore
        return encoder.encode(input);
    }
    /**
     * Converts the given byte array to a number. Cannot parse a number
     * larger than u64, specifically, 2**53-1 (javascripts max number).
     */
    function toNumber(bytes, le) {
        if (le === void 0) { le = false; }
        if (bytes.length > 8) {
            throw new Error('Cannot parse a number greater than u64');
        }
        var b = toHex(bytes).substr(2);
        if (le) {
            var match = b.match(/../g);
            if (match !== null) {
                b = match.reverse().join('');
            }
        }
        var result = parseInt(b, 16);
        if (result >= Number.MAX_SAFE_INTEGER) {
            throw new Error("Overflowed when converting to number: " + bytes);
        }
        return result;
    }
    /**
     * @returns the given bytes as a Uint8Array.
     * @throws  if the given bytes is not of the given `length`.
     */
    function assertLength(bytes, length) {
        if (typeof bytes === 'string') {
            bytes = parseHex(bytes);
        }
        if (bytes.length !== length) {
            throw new InvalidBytesError(bytes, "invalid bytes length: received " + bytes.length + " but expected " + length);
        }
        return bytes;
    }
    var InvalidBytesError = /** @class */ (function (_super) {
        __extends$1(InvalidBytesError, _super);
        function InvalidBytesError(bytes) {
            var params = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                params[_i - 1] = arguments[_i];
            }
            var _this = _super.apply(this, params) || this;
            _this.bytes = bytes;
            return _this;
        }
        return InvalidBytesError;
    }(Error));

    var bytes = /*#__PURE__*/Object.freeze({
        parseHex: parseHex,
        toHex: toHex,
        parseNumber: parseNumber,
        concat: concat,
        decodeUtf8: decodeUtf8,
        encodeUtf8: encodeUtf8,
        toNumber: toNumber,
        assertLength: assertLength,
        InvalidBytesError: InvalidBytesError
    });

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
    }

    function createCommonjsModule$1(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var uint32 = createCommonjsModule$1(function (module) {
    /* jshint bitwise: false */

    /**
     * @license (c) Franz X Antesberger 2013
     */
    (function (exporter) {

        var POW_2_32 = 0x0100000000;

        //
        //  Creating and Extracting
        //

        /**
         *  Creates an uint32 from the given bytes in big endian order.
         *  @param {Number} highByte the high byte
         *  @param {Number} secondHighByte the 2nd high byte
         *  @param {Number} thirdHighByte the 3rd high byte
         *  @param {Number} lowByte the low byte
         *  @returns highByte concat secondHighByte concat thirdHighByte concat lowByte
         */
        exporter.fromBytesBigEndian = function (highByte, secondHighByte, thirdHighByte, lowByte) {
            return ((highByte << 24) | (secondHighByte << 16) | (thirdHighByte << 8) | lowByte) >>> 0;
        };

        /**
         *  Returns the byte.
         *  e.g. when byteNo is 0, the high byte is returned, when byteNo = 3 the low byte is returned.
         *  @param {Number} uint32value the source to be extracted
         *  @param {Number} byteNo 0-3 the byte number, 0 is the high byte, 3 the low byte
         *  @returns {Number} the 0-255 byte according byteNo
         */
        exporter.getByteBigEndian = function (uint32value, byteNo) {
            return (uint32value >>> (8 * (3 - byteNo))) & 0xff;
        };

        /**
         *  Returns the bytes as array.
         *  @param {Number} uint32value the source to be extracted
         *  @returns {Array} the array [highByte, 2ndHighByte, 3rdHighByte, lowByte]
         */
        exporter.getBytesBigEndian = function (uint32value) {
            return [
                exporter.getByteBigEndian(uint32value, 0),
                exporter.getByteBigEndian(uint32value, 1),
                exporter.getByteBigEndian(uint32value, 2),
                exporter.getByteBigEndian(uint32value, 3)
            ];
        };

        /**
         *  Converts a given uin32 to a hex string including leading zeros.
         *  @param {Number} uint32value the uint32 to be stringified
         *  @param {Number} optionalMinLength the optional (default 8)
         */
        exporter.toHex = function (uint32value, optionalMinLength) {
            optionalMinLength = optionalMinLength || 8;
            var result = uint32value.toString(16);
            if (result.length < optionalMinLength) {
                result = new Array(optionalMinLength - result.length + 1).join('0') + result;
            }
            return result;
        };

        /**
         *  Converts a number to an uint32.
         *  @param {Number} number the number to be converted.
         *  @return {Number} an uint32 value
         */
        exporter.toUint32 = function (number) {
            // the shift operator forces js to perform the internal ToUint32 (see ecmascript spec 9.6)
            return number >>> 0;
        };

        /**
         *  Returns the part above the uint32 border.
         *  Depending to the javascript engine, that are the 54-32 = 22 high bits
         *  @param {Number} number the number to extract the high part
         *  @return {Number} the high part of the number
         */
        exporter.highPart = function (number) {
            return exporter.toUint32(number / POW_2_32);
        };

        //
        //  Bitwise Logical Operators
        //

        /**
         *  Returns a bitwise OR operation on two or more values.
         *  @param {Number} uint32val0 first uint32 value
         *  @param {Number} argv one or more uint32 values
         *  @return {Number} the bitwise OR uint32 value
         */
        exporter.or = function (uint32val0, argv) {
            var result = uint32val0;
            for (var index = 1; index < arguments.length; index += 1) {
                result = (result | arguments[index]);
            }
            return result >>> 0;
        };

        /**
         *  Returns a bitwise AND operation on two or more values.
         *  @param {Number} uint32val0 first uint32 value
         *  @param {Number} argv one or more uint32 values
         *  @return {Number} the bitwise AND uint32 value
         */
        exporter.and = function (uint32val0, argv) {
            var result = uint32val0;
            for (var index = 1; index < arguments.length; index += 1) {
                result = (result & arguments[index]);
            }
            return result >>> 0;
        };

        /**
         *  Returns a bitwise XOR operation on two or more values.
         *  @param {Number} uint32val0 first uint32 value
         *  @param {Number} argv one or more uint32 values
         *  @return {Number} the bitwise XOR uint32 value
         */
        exporter.xor = function (uint32val0, argv) {
            var result = uint32val0;
            for (var index = 1; index < arguments.length; index += 1) {
                result = (result ^ arguments[index]);
            }
            return result >>> 0;
        };

        exporter.not = function (uint32val) {
            return (~uint32val) >>> 0;
        };

        //
        // Shifting and Rotating
        //

        /**
         *  Returns the uint32 representation of a << operation.
         *  @param {Number} uint32val the word to be shifted
         *  @param {Number} numBits the number of bits to be shifted (0-31)
         *  @returns {Number} the uint32 value of the shifted word
         */
        exporter.shiftLeft = function (uint32val, numBits) {
            return (uint32val << numBits) >>> 0;
        };

        /**
         *  Returns the uint32 representation of a >>> operation.
         *  @param {Number} uint32val the word to be shifted
         *  @param {Number} numBits the number of bits to be shifted (0-31)
         *  @returns {Number} the uint32 value of the shifted word
         */
        exporter.shiftRight = function (uint32val, numBits) {
            return uint32val >>> numBits;
        };

        exporter.rotateLeft = function (uint32val, numBits) {
            return (((uint32val << numBits) >>> 0) | (uint32val >>> (32 - numBits))) >>> 0;
        };

        exporter.rotateRight = function (uint32val, numBits) {
            return (((uint32val) >>> (numBits)) | ((uint32val) << (32 - numBits)) >>> 0) >>> 0;
        };

        //
        // Logical Gates
        //

        /**
         *  Bitwise choose bits from y or z, as a bitwise x ? y : z
         */
        exporter.choose = function (x, y, z) {
            return ((x & (y ^ z)) ^ z) >>> 0;
        };

        /**
         * Majority gate for three parameters. Takes bitwise the majority of x, y and z,
         * @see https://en.wikipedia.org/wiki/Majority_function
         */
        exporter.majority = function (x, y, z) {
            return ((x & (y | z)) | (y & z)) >>> 0;
        };

        //
        //  Arithmetic
        //

        /**
         *  Adds the given values modulus 2^32.
         *  @returns the sum of the given values modulus 2^32
         */
        exporter.addMod32 = function (uint32val0/*, optionalValues*/) {
            var result = uint32val0;
            for (var index = 1; index < arguments.length; index += 1) {
                result += arguments[index];
            }
            return result >>> 0;
        };

        /**
         *  Returns the log base 2 of the given value. That is the number of the highest set bit.
         *  @param {Number} uint32val the value, the log2 is calculated of
         *  @return {Number} the logarithm base 2, an integer between 0 and 31
         */
        exporter.log2 = function (uint32val) {
            return Math.floor(Math.log(uint32val) / Math.LN2);
        };

    /*
        // this implementation does the same, looks much funnier, but takes 2 times longer (according to jsperf) ...
        var log2_u = new Uint32Array(2);
        var log2_d = new Float64Array(log2_u.buffer);

        exporter.log2 = function (uint32val) {
            // Ported from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogIEEE64Float to javascript
            // (public domain)
            if (uint32val === 0) {
                return -Infinity;
            }
            // fill in the low part
            log2_u[0] = uint32val;
            // set the mantissa to 2^52
            log2_u[1] = 0x43300000;
            // subtract 2^52
            log2_d[0] -= 0x10000000000000;
            return (log2_u[1] >>> 20) - 0x3FF;
        };
    */

        /**
         *  Returns the the low and the high uint32 of the multiplication.
         *  @param {Number} factor1 an uint32
         *  @param {Number} factor2 an uint32
         *  @param {Uint32Array[2]} resultUint32Array2 the Array, where the result will be written to
         *  @returns undefined
         */
        exporter.mult = function (factor1, factor2, resultUint32Array2) {
            var high16 =  ((factor1 & 0xffff0000) >>> 0) * factor2;
            var low16 = (factor1 & 0x0000ffff) * factor2;
            // the addition is dangerous, because the result will be rounded, so the result depends on the lowest bits, which will be cut away!
            var carry = ((exporter.toUint32(high16) + exporter.toUint32(low16)) >= POW_2_32) ? 1 : 0;
            resultUint32Array2[0] = (exporter.highPart(high16) + exporter.highPart(low16) + carry) >>> 0;
            resultUint32Array2[1] = ((high16 >>> 0) + (low16 >>> 0));// >>> 0;
        };

    }) (module.exports = {});
    });

    // Copyright (c) 2016 Thomas Pornin <pornin@bolet.org>
    // Copyright (c) 2017 Yawning Angel <yawning at schwanenlied dot me>
    // Copyright (c) 2019 Oasis Labs Inc. <info@oasislabs.com>
    //
    // Permission is hereby granted, free of charge, to any person obtaining
    // a copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to
    // permit persons to whom the Software is furnished to do so, subject to
    // the following conditions:
    //
    // The above copyright notice and this permission notice shall be
    // included in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    // BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    // SOFTWARE.



    const rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36];
    const oddsMask = uint32.fromBytesBigEndian(0x55, 0x55, 0x55, 0x55);
    const evensMask = uint32.fromBytesBigEndian(0xaa, 0xaa, 0xaa, 0xaa);
    const cl4 = uint32.fromBytesBigEndian(0x33, 0x33, 0x33, 0x33);
    const ch4 = uint32.fromBytesBigEndian(0xcc, 0xcc, 0xcc, 0xcc);
    const cl8 = uint32.fromBytesBigEndian(0x0f, 0x0f, 0x0f, 0x0f);
    const ch8 = uint32.fromBytesBigEndian(0xf0, 0xf0, 0xf0, 0xf0);

    const shiftRowsMask0 = uint32.fromBytesBigEndian(0x00, 0x00, 0x00, 0xff);
    const shiftRowsMask1 = uint32.fromBytesBigEndian(0x00, 0x00, 0xfc, 0x00);
    const shiftRowsMask2 = uint32.fromBytesBigEndian(0x00, 0x00, 0x03, 0x00);
    const shiftRowsMask3 = uint32.fromBytesBigEndian(0x00, 0xf0, 0x00, 0x00);
    const shiftRowsMask4 = uint32.fromBytesBigEndian(0x00, 0x0f, 0x00, 0x00);
    const shiftRowsMask5 = uint32.fromBytesBigEndian(0xc0, 0x00, 0x00, 0x00);
    const shiftRowsMask6 = uint32.fromBytesBigEndian(0x3f, 0x00, 0x00, 0x00);

    function newQ() {
    	return new Uint32Array(8); // q
    }

    // AddRoundKey
    function addRoundKey(q, sk) {
    	q[0] = uint32.xor(q[0], sk[0]);
    	q[1] = uint32.xor(q[1], sk[1]);
    	q[2] = uint32.xor(q[2], sk[2]);
    	q[3] = uint32.xor(q[3], sk[3]);
    	q[4] = uint32.xor(q[4], sk[4]);
    	q[5] = uint32.xor(q[5], sk[5]);
    	q[6] = uint32.xor(q[6], sk[6]);
    	q[7] = uint32.xor(q[7], sk[7]);
    }

    // SubBytes
    function subBytes(q) {
    	// This S-box implementation is a straightforward translation of
    	// the circuit described by Boyar and Peralta in "A new
    	// combinational logic minimization technique with applications
    	// to cryptology" (https://eprint.iacr.org/2009/191.pdf).
    	//
    	// Note that variables x* (input) and s* (output) are numbered
    	// in "reverse" order (x0 is the high bit, x7 is the low bit).

    	const x0 = q[7];
    	const x1 = q[6];
    	const x2 = q[5];
    	const x3 = q[4];
    	const x4 = q[3];
    	const x5 = q[2];
    	const x6 = q[1];
    	const x7 = q[0];

    	//
    	// Top linear transformation.
    	//
    	const y14 = uint32.xor(x3, x5);
    	const y13 = uint32.xor(x0, x6);
    	const y9 = uint32.xor(x0, x3);
    	const y8 = uint32.xor(x0, x5);
    	const t0 = uint32.xor(x1, x2);
    	const y1 = uint32.xor(t0, x7);
    	const y4 = uint32.xor(y1, x3);
    	const y12 = uint32.xor(y13, y14);
    	const y2 = uint32.xor(y1, x0);
    	const y5 = uint32.xor(y1, x6);
    	const y3 = uint32.xor(y5, y8);
    	const t1 = uint32.xor(x4, y12);
    	const y15 = uint32.xor(t1, x5);
    	const y20 = uint32.xor(t1, x1);
    	const y6 = uint32.xor(y15, x7);
    	const y10 = uint32.xor(y15, t0);
    	const y11 = uint32.xor(y20, y9);
    	const y7 = uint32.xor(x7, y11);
    	const y17 = uint32.xor(y10, y11);
    	const y19 = uint32.xor(y10, y8);
    	const y16 = uint32.xor(t0, y11);
    	const y21 = uint32.xor(y13, y16);
    	const y18 = uint32.xor(x0, y16);

    	//
    	// Non-linear section.
    	//
    	const t2 = uint32.and(y12, y15);
    	const t3 = uint32.and(y3, y6);
    	const t4 = uint32.xor(t3, t2);
    	const t5 = uint32.and(y4, x7);
    	const t6 = uint32.xor(t5, t2);
    	const t7 = uint32.and(y13, y16);
    	const t8 = uint32.and(y5, y1);
    	const t9 = uint32.xor(t8, t7);
    	const t10 = uint32.and(y2, y7);
    	const t11 = uint32.xor(t10, t7);
    	const t12 = uint32.and(y9, y11);
    	const t13 = uint32.and(y14, y17);
    	const t14 = uint32.xor(t13, t12);
    	const t15 = uint32.and(y8, y10);
    	const t16 = uint32.xor(t15, t12);
    	const t17 = uint32.xor(t4, t14);
    	const t18 = uint32.xor(t6, t16);
    	const t19 = uint32.xor(t9, t14);
    	const t20 = uint32.xor(t11, t16);
    	const t21 = uint32.xor(t17, y20);
    	const t22 = uint32.xor(t18, y19);
    	const t23 = uint32.xor(t19, y21);
    	const t24 = uint32.xor(t20, y18);

    	const t25 = uint32.xor(t21, t22);
    	const t26 = uint32.and(t21, t23);
    	const t27 = uint32.xor(t24, t26);
    	const t28 = uint32.and(t25, t27);
    	const t29 = uint32.xor(t28, t22);
    	const t30 = uint32.xor(t23, t24);
    	const t31 = uint32.xor(t22, t26);
    	const t32 = uint32.and(t31, t30);
    	const t33 = uint32.xor(t32, t24);
    	const t34 = uint32.xor(t23, t33);
    	const t35 = uint32.xor(t27, t33);
    	const t36 = uint32.and(t24, t35);
    	const t37 = uint32.xor(t36, t34);
    	const t38 = uint32.xor(t27, t36);
    	const t39 = uint32.and(t29, t38);
    	const t40 = uint32.xor(t25, t39);

    	const t41 = uint32.xor(t40, t37);
    	const t42 = uint32.xor(t29, t33);
    	const t43 = uint32.xor(t29, t40);
    	const t44 = uint32.xor(t33, t37);
    	const t45 = uint32.xor(t42, t41);
    	const z0 = uint32.and(t44, y15);
    	const z1 = uint32.and(t37, y6);
    	const z2 = uint32.and(t33, x7);
    	const z3 = uint32.and(t43, y16);
    	const z4 = uint32.and(t40, y1);
    	const z5 = uint32.and(t29, y7);
    	const z6 = uint32.and(t42, y11);
    	const z7 = uint32.and(t45, y17);
    	const z8 = uint32.and(t41, y10);
    	const z9 = uint32.and(t44, y12);
    	const z10 = uint32.and(t37, y3);
    	const z11 = uint32.and(t33, y4);
    	const z12 = uint32.and(t43, y13);
    	const z13 = uint32.and(t40, y5);
    	const z14 = uint32.and(t29, y2);
    	const z15 = uint32.and(t42, y9);
    	const z16 = uint32.and(t45, y14);
    	const z17 = uint32.and(t41, y8);

    	//
    	// Bottom linear transformation.
    	//
    	const t46 = uint32.xor(z15, z16);
    	const t47 = uint32.xor(z10, z11);
    	const t48 = uint32.xor(z5, z13);
    	const t49 = uint32.xor(z9, z10);
    	const t50 = uint32.xor(z2, z12);
    	const t51 = uint32.xor(z2, z5);
    	const t52 = uint32.xor(z7, z8);
    	const t53 = uint32.xor(z0, z3);
    	const t54 = uint32.xor(z6, z7);
    	const t55 = uint32.xor(z16, z17);
    	const t56 = uint32.xor(z12, t48);
    	const t57 = uint32.xor(t50, t53);
    	const t58 = uint32.xor(z4, t46);
    	const t59 = uint32.xor(z3, t54);
    	const t60 = uint32.xor(t46, t57);
    	const t61 = uint32.xor(z14, t57);
    	const t62 = uint32.xor(t52, t58);
    	const t63 = uint32.xor(t49, t58);
    	const t64 = uint32.xor(z4, t59);
    	const t65 = uint32.xor(t61, t62);
    	const t66 = uint32.xor(z1, t63);
    	const s0 = uint32.xor(t59, t63);
    	const s6 = uint32.xor(t56, uint32.not(t62));
    	const s7 = uint32.xor(t48, uint32.not(t60));
    	const t67 = uint32.xor(t64, t65);
    	const s3 = uint32.xor(t53, t66);
    	const s4 = uint32.xor(t51, t66);
    	const s5 = uint32.xor(t47, t65);
    	const s1 = uint32.xor(t64, uint32.not(s3));
    	const s2 = uint32.xor(t55, uint32.not(t67));

    	q[7] = s0;
    	q[6] = s1;
    	q[5] = s2;
    	q[4] = s3;
    	q[3] = s4;
    	q[2] = s5;
    	q[1] = s6;
    	q[0] = s7;
    }

    // ShiftRows
    function shiftRows(q) {
    	for (let i = 0; i < 8; i++) {
    		const x = q[i];

    		q[i] = uint32.or(
    			uint32.and(x, shiftRowsMask0),
    			uint32.shiftRight(uint32.and(x, shiftRowsMask1), 2),
    			uint32.shiftLeft(uint32.and(x, shiftRowsMask2), 6),
    			uint32.shiftRight(uint32.and(x, shiftRowsMask3), 4),
    			uint32.shiftLeft(uint32.and(x, shiftRowsMask4), 4),
    			uint32.shiftRight(uint32.and(x, shiftRowsMask5), 6),
    			uint32.shiftLeft(uint32.and(x, shiftRowsMask6), 2)
    		);
    	}
    }

    // MixColumns
    function mixColumns(q) {
    	const q0 = q[0];
    	const q1 = q[1];
    	const q2 = q[2];
    	const q3 = q[3];
    	const q4 = q[4];
    	const q5 = q[5];
    	const q6 = q[6];
    	const q7 = q[7];

    	const r0 = uint32.or(uint32.shiftRight(q0, 8), uint32.shiftLeft(q0, 24));
    	const r1 = uint32.or(uint32.shiftRight(q1, 8), uint32.shiftLeft(q1, 24));
    	const r2 = uint32.or(uint32.shiftRight(q2, 8), uint32.shiftLeft(q2, 24));
    	const r3 = uint32.or(uint32.shiftRight(q3, 8), uint32.shiftLeft(q3, 24));
    	const r4 = uint32.or(uint32.shiftRight(q4, 8), uint32.shiftLeft(q4, 24));
    	const r5 = uint32.or(uint32.shiftRight(q5, 8), uint32.shiftLeft(q5, 24));
    	const r6 = uint32.or(uint32.shiftRight(q6, 8), uint32.shiftLeft(q6, 24));
    	const r7 = uint32.or(uint32.shiftRight(q7, 8), uint32.shiftLeft(q7, 24));

    	q[0] = uint32.xor(q7, r7, r0, uint32.rotateRight(uint32.xor(q0, r0), 16));
    	q[1] = uint32.xor(q0, r0, q7, r7, r1, uint32.rotateRight(uint32.xor(q1, r1), 16));
    	q[2] = uint32.xor(q1, r1, r2, uint32.rotateRight(uint32.xor(q2, r2), 16));
    	q[3] = uint32.xor(q2, r2, q7, r7, r3, uint32.rotateRight(uint32.xor(q3, r3), 16));
    	q[4] = uint32.xor(q3, r3, q7, r7, r4, uint32.rotateRight(uint32.xor(q4, r4), 16));
    	q[5] = uint32.xor(q4, r4, r5, uint32.rotateRight(uint32.xor(q5, r5), 16));
    	q[6] = uint32.xor(q5, r5, r6, uint32.rotateRight(uint32.xor(q6, r6), 16));
    	q[7] = uint32.xor(q6, r6, r7, uint32.rotateRight(uint32.xor(q7, r7), 16));
    }

    function load4xU32(q, src) {
    	const srcView = new DataView(src.buffer);
    	q[0] = srcView.getUint32(0 + src.byteOffset, true);
    	q[2] = srcView.getUint32(4 + src.byteOffset, true);
    	q[4] = srcView.getUint32(8 + src.byteOffset, true);
    	q[6] = srcView.getUint32(12 + src.byteOffset, true);
    	q[1] = 0;
    	q[3] = 0;
    	q[5] = 0;
    	q[7] = 0;
    	ortho(q);
    }

    function load8xU32(q, src0, src1) {
    	const src0View = new DataView(src0.buffer);
    	const src1View = new DataView(src1.buffer);
    	q[0] = src0View.getUint32(0 + src0.byteOffset, true);
    	q[2] = src0View.getUint32(4 + src0.byteOffset, true);
    	q[4] = src0View.getUint32(8 + src0.byteOffset, true);
    	q[6] = src0View.getUint32(12 + src0.byteOffset, true);
    	q[1] = src1View.getUint32(0 + src1.byteOffset, true);
    	q[3] = src1View.getUint32(4 + src1.byteOffset, true);
    	q[5] = src1View.getUint32(8 + src1.byteOffset, true);
    	q[7] = src1View.getUint32(12 + src1.byteOffset, true);
    	ortho(q);
    }

    function store4xU32(dst, q) {
    	ortho(q);
    	const dstView = new DataView(dst.buffer);
    	dstView.setUint32(0 + dst.byteOffset, q[0], true);
    	dstView.setUint32(4 + dst.byteOffset, q[2], true);
    	dstView.setUint32(8 + dst.byteOffset, q[4], true);
    	dstView.setUint32(12 + dst.byteOffset, q[6], true);
    }

    function store8xU32(dst0, dst1, q) {
    	ortho(q);
    	const dst0View = new DataView(dst0.buffer);
    	const dst1View = new DataView(dst1.buffer);
    	dst0View.setUint32(0 + dst0.byteOffset, q[0], true);
    	dst0View.setUint32(4 + dst0.byteOffset, q[2], true);
    	dst0View.setUint32(8 + dst0.byteOffset, q[4], true);
    	dst0View.setUint32(12 + dst0.byteOffset, q[6], true);
    	dst1View.setUint32(0 + dst1.byteOffset, q[1], true);
    	dst1View.setUint32(4 + dst1.byteOffset, q[3], true);
    	dst1View.setUint32(8 + dst1.byteOffset, q[5], true);
    	dst1View.setUint32(12 + dst1.byteOffset, q[7], true);
    }

    function ortho(q) {
    	for (let i = 0; i < 8; i += 2) {
    		const q0 = q[i];
    		const q1 = q[i+1];

    		q[i] = uint32.or(uint32.and(q0, oddsMask), uint32.shiftLeft(uint32.and(q1, oddsMask), 1));
    		q[i+1] = uint32.or(uint32.shiftRight(uint32.and(q0, evensMask), 1), uint32.and(q1, evensMask));
    	}

    	for (let i = 0; i < 8; i += 4) {
    		const q0 = q[i];
    		const q1 = q[i+1];
    		const q2 = q[i+2];
    		const q3 = q[i+3];

    		q[i] = uint32.or(uint32.and(q0, cl4), uint32.shiftLeft(uint32.and(q2, cl4), 2));
    		q[i+2] = uint32.or(uint32.shiftRight(uint32.and(q0, ch4), 2), uint32.and(q2, ch4));
    		q[i+1] = uint32.or(uint32.and(q1, cl4), uint32.shiftLeft(uint32.and(q3, cl4), 2));
    		q[i+3] = uint32.or(uint32.shiftRight(uint32.and(q1, ch4), 2), uint32.and(q3, ch4));
    	}

    	for (let i = 0; i < 4; i++) {
    		const q0 = q[i];
    		const q4 = q[i+4];

    		q[i] = uint32.or(uint32.and(q0, cl8), uint32.shiftLeft(uint32.and(q4, cl8), 4));
    		q[i+4] = uint32.or(uint32.shiftRight(uint32.and(q0, ch8), 4), uint32.and(q4, ch8));
    	}
    }

    function rkeyOrtho(q, key) {
    	const keyView = new DataView(key.buffer);
    	for (let i = 0; i < 4; i++) {
    		const x = keyView.getUint32(i*4 + key.byteOffset, true);
    		q[i*2] = x;
    		q[i*2+1] = x;
    	}
    	ortho(q);

    	for (let i = 0, j = 0; i < 4; i = i + 1, j = j + 2) {
    		let x = uint32.or(uint32.and(q[j+0], oddsMask), uint32.and(q[j+1], evensMask));
    		let y = x;

    		x = uint32.and(x, oddsMask);
    		q[j] = uint32.or(x, uint32.shiftLeft(x, 1));
    		y = uint32.and(y, evensMask);
    		q[j+1] = uint32.or(y, uint32.shiftRight(y, 1));
    	}
    }

    function skeyExpand(skey, numRounds, compSkey) {
    	const n = (numRounds + 1) * 4;

    	for (let u = 0, v = 0; u < n; u = u + 1, v = v + 2) {
    		let x = compSkey[u];
    		let y = compSkey[u];

    		x = uint32.and(x, oddsMask);
    		skey[v] = uint32.or(x, uint32.shiftLeft(x, 1));
    		y = uint32.and(y, evensMask);
    		skey[v+1] = uint32.or(y, uint32.shiftRight(y, 1));
    	}
    }

    //
    // ECB-AES (example/testing), and associated package private helpers.
    //

    function _subWord(x) {
    	let q = new	Uint32Array([x, x, x, x, x, x, x, x]);
    	ortho(q);
    	subBytes(q);
    	ortho(q);
    	return q[0];
    }

    function keySched(compSkey, key) {
    	let numRounds = 0;
    	const keyLen = key.byteLength;
    	switch (keyLen) {
    	case 16:
    		numRounds = 10;
    		break;
    	case 24:
    		numRounds = 12;
    		break;
    	case 32:
    		numRounds = 14;
    		break;
    	default:
    		throw 'aes: invalid key length';
    	}

    	let skey = new Uint32Array(120);
    	let tmp = 0;
    	const nk = keyLen / 4;
    	const nkf = (numRounds + 1) * 4;
    	const keyView = new DataView(key.buffer);
    	for (let i = 0; i < nk; i++) {
    		tmp = keyView.getUint32(i*4 + key.byteOffset, true);
    		skey[i*2] = tmp;
    		skey[i*2+1] = tmp;
    	}
    	for (let i = nk, j = 0, k = 0; i < nkf; i++) {
    		if (j == 0) {
    			tmp = uint32.or(uint32.shiftLeft(tmp, 24), uint32.shiftRight(tmp, 8));
    			tmp = uint32.xor(_subWord(tmp), uint32.fromBytesBigEndian(0x00, 0x00, 0x00, rcon[k]));
    		} else if (nk > 6 && j == 4) {
    			tmp = _subWord(tmp);
    		}
    		tmp = uint32.xor(tmp, skey[(i-nk)*2]);
    		skey[i*2] = tmp;
    		skey[i*2+1] = tmp;
    		j++;
    		if (j == nk) {
    			j = 0;
    			k++;
    		}
    	}
    	for (let i = 0; i < nkf; i += 4) {
    		let stmp = skey.slice(i*2, i*2+8);
    		ortho(stmp);
    		for (let j = 0; j < 8; j++) {
    			skey[i*2+j] = stmp[j];
    		}
    	}
    	for (let i = 0, j = 0; i < nkf; i = i + 1, j = j + 2) {
    		compSkey[i] = uint32.or(uint32.and(skey[j], oddsMask), uint32.and(skey[j+1], evensMask));
    	}
    	return numRounds;
    }

    function _encrypt(numRounds, skey, q) {
    	addRoundKey(q, skey);
    	for (let u = 1; u < numRounds; u++) {
    		subBytes(q);
    		shiftRows(q);
    		mixColumns(q);
    		addRoundKey(q, skey.slice(u*8, u*8+8));
    	}
    	subBytes(q);
    	shiftRows(q);
    	addRoundKey(q, skey.slice(numRounds*8, numRounds*8+8));
    }

    class ECB {
    	constructor(key) {
    		let skey = new Uint32Array(60);

    		this.numRounds = keySched(skey, key);
    		this.skeyExpanded = new Uint32Array(120);
    		skeyExpand(this.skeyExpanded, this.numRounds, skey);
    	}

    	encrypt(dst, src) {
    		let q = newQ();

    		load4xU32(q, src);
    		_encrypt(this.numRounds, this.skeyExpanded, q);
    		store4xU32(dst, q);
    	}

    	encrypt2x(dst0, dst1, src0, src1) {
    		let q = newQ();

    		load8xU32(q, src0, src1);
    		_encrypt(this.numRounds, this.skeyExpanded, q);
    		store8xU32(dst0, dst1, q);
    	}
    }

    var aes = {
    	// ECB-AES, probably shouldn't be used for more than testing.
    	ECB: ECB,

    	// Implementation internals, exposed for the purpose of constructing
    	// things based on the AES round function.
    	newQ,
    	load4xU32,
    	load8xU32,
    	store4xU32,
    	store8xU32,
    	ortho,
    	rkeyOrtho,
    	addRoundKey,
    	subBytes,
    	shiftRows,
    	mixColumns,

    	skeyExpand,
    	keySched,
    };

    // Copyright (c) 2019 Oasis Labs Inc. <info@oasislabs.com>
    //
    // Permission is hereby granted, free of charge, to any person obtaining
    // a copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to
    // permit persons to whom the Software is furnished to do so, subject to
    // the following conditions:
    //
    // The above copyright notice and this permission notice shall be
    // included in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    // BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    // SOFTWARE.



    const te0 = new Uint32Array([
    	0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d,
    	0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554,
    	0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d,
    	0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a,
    	0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87,
    	0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,
    	0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea,
    	0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b,
    	0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a,
    	0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f,
    	0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108,
    	0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,
    	0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e,
    	0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5,
    	0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d,
    	0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f,
    	0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e,
    	0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb,
    	0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce,
    	0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497,
    	0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c,
    	0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed,
    	0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b,
    	0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a,
    	0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16,
    	0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594,
    	0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81,
    	0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3,
    	0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a,
    	0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504,
    	0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163,
    	0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d,
    	0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f,
    	0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739,
    	0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47,
    	0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395,
    	0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f,
    	0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883,
    	0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c,
    	0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76,
    	0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e,
    	0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4,
    	0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6,
    	0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b,
    	0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7,
    	0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0,
    	0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25,
    	0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818,
    	0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72,
    	0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651,
    	0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21,
    	0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85,
    	0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa,
    	0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12,
    	0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0,
    	0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9,
    	0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133,
    	0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7,
    	0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920,
    	0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a,
    	0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17,
    	0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8,
    	0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11,
    	0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a
    ]);

    const te1 = new Uint32Array([
    	0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b,
    	0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5,
    	0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b,
    	0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676,
    	0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d,
    	0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0,
    	0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf,
    	0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0,
    	0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626,
    	0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc,
    	0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1,
    	0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515,
    	0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3,
    	0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a,
    	0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2,
    	0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575,
    	0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a,
    	0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0,
    	0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3,
    	0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484,
    	0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded,
    	0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b,
    	0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939,
    	0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf,
    	0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb,
    	0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585,
    	0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f,
    	0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8,
    	0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f,
    	0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5,
    	0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121,
    	0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2,
    	0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec,
    	0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717,
    	0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d,
    	0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373,
    	0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc,
    	0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888,
    	0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414,
    	0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb,
    	0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a,
    	0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c,
    	0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262,
    	0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979,
    	0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d,
    	0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9,
    	0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea,
    	0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808,
    	0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e,
    	0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6,
    	0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f,
    	0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a,
    	0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666,
    	0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e,
    	0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9,
    	0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e,
    	0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111,
    	0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494,
    	0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9,
    	0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf,
    	0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d,
    	0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868,
    	0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f,
    	0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616
    ]);

    const te2 = new Uint32Array([
    	0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b,
    	0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5,
    	0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b,
    	0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76,
    	0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d,
    	0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0,
    	0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af,
    	0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0,
    	0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26,
    	0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc,
    	0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1,
    	0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15,
    	0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3,
    	0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a,
    	0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2,
    	0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75,
    	0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a,
    	0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0,
    	0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3,
    	0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384,
    	0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed,
    	0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b,
    	0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239,
    	0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf,
    	0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb,
    	0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185,
    	0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f,
    	0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8,
    	0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f,
    	0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5,
    	0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221,
    	0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2,
    	0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec,
    	0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17,
    	0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d,
    	0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673,
    	0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc,
    	0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88,
    	0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814,
    	0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb,
    	0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a,
    	0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c,
    	0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462,
    	0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279,
    	0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d,
    	0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9,
    	0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea,
    	0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008,
    	0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e,
    	0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6,
    	0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f,
    	0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a,
    	0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66,
    	0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e,
    	0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9,
    	0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e,
    	0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211,
    	0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394,
    	0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9,
    	0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df,
    	0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d,
    	0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068,
    	0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f,
    	0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16
    ]);

    const te3 = new Uint32Array([
    	0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6,
    	0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491,
    	0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56,
    	0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec,
    	0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa,
    	0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb,
    	0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45,
    	0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b,
    	0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c,
    	0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83,
    	0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9,
    	0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a,
    	0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d,
    	0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f,
    	0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf,
    	0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea,
    	0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34,
    	0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b,
    	0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d,
    	0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713,
    	0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1,
    	0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6,
    	0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72,
    	0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85,
    	0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed,
    	0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411,
    	0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe,
    	0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b,
    	0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05,
    	0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1,
    	0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342,
    	0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf,
    	0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3,
    	0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e,
    	0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a,
    	0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6,
    	0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3,
    	0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b,
    	0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28,
    	0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad,
    	0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14,
    	0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8,
    	0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4,
    	0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2,
    	0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da,
    	0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049,
    	0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf,
    	0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810,
    	0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c,
    	0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197,
    	0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e,
    	0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f,
    	0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc,
    	0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c,
    	0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069,
    	0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927,
    	0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322,
    	0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733,
    	0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9,
    	0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5,
    	0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a,
    	0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0,
    	0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e,
    	0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c
    ]);

    const andMask = uint32.fromBytesBigEndian(0x00, 0x00, 0x00, 0xff);

    function aesencVartime(s0, s1, s2, s3, roundKey) {
    	const rkView = new DataView(roundKey.buffer);
    	const rk0 = rkView.getUint32(0 + roundKey.byteOffset, false);
    	const rk1 = rkView.getUint32(4 + roundKey.byteOffset, false);
    	const rk2 = rkView.getUint32(8 + roundKey.byteOffset, false);
    	const rk3 = rkView.getUint32(12 + roundKey.byteOffset, false);

    	const t0 = uint32.xor(
    		te0[uint32.and(uint32.shiftRight(s0, 24), andMask)],
    		te1[uint32.and(uint32.shiftRight(s1, 16), andMask)],
    		te2[uint32.and(uint32.shiftRight(s2, 8), andMask)],
    		te3[uint32.and(s3, andMask)],
    		rk0
    	);

    	const t1 = uint32.xor(
    		te0[uint32.and(uint32.shiftRight(s1, 24), andMask)],
    		te1[uint32.and(uint32.shiftRight(s2, 16), andMask)],
    		te2[uint32.and(uint32.shiftRight(s3, 8), andMask)],
    		te3[uint32.and(s0, andMask)],
    		rk1
    	);

    	const t2 = uint32.xor(
    		te0[uint32.and(uint32.shiftRight(s2, 24), andMask)],
    		te1[uint32.and(uint32.shiftRight(s3, 16), andMask)],
    		te2[uint32.and(uint32.shiftRight(s0, 8), andMask)],
    		te3[uint32.and(s1, andMask)],
    		rk2
    	);

    	const t3 = uint32.xor(
    		te0[uint32.and(uint32.shiftRight(s3, 24), andMask)],
    		te1[uint32.and(uint32.shiftRight(s0, 16), andMask)],
    		te2[uint32.and(uint32.shiftRight(s1, 8), andMask)],
    		te3[uint32.and(s2, andMask)],
    		rk3
    	);

    	return [t0, t1, t2, t3];
    }

    var unsafe = {
    	aesencVartime
    };

    // Copyright (c) 2019 Oasis Labs Inc. <info@oasislabs.com>
    //
    // Permission is hereby granted, free of charge, to any person obtaining
    // a copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to
    // permit persons to whom the Software is furnished to do so, subject to
    // the following conditions:
    //
    // The above copyright notice and this permission notice shall be
    // included in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    // BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    // SOFTWARE.





    const KeySize = 32;
    const NonceSize = 15;
    const TagSize = 16;

    const stkSize = 16;
    const rounds = 16;
    const blockSize = 16;
    const tweakSize = 16;

    const prefixADBlock = 0x02;
    const prefixADFinal = 0x06;
    const prefixMsgBlock = 0x00;
    const prefixMsgFinal = 0x04;
    const prefixTag = 0x01;
    const prefixShift = 4;

    function xorBytes(dst, a, b, n) {
    	for (let i = 0; i < n; i++) {
    		dst[i] = a[i] ^ b[i];
    	}
    }

    //
    // TWEAKEY routines
    //

    const rcons = new Uint8Array([
    	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a,
    	0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
    	0x72
    ]);

    function h(t) {
    	const tmp = new Uint8Array([
    		t[1], t[6], t[11], t[12], t[5], t[10], t[15], t[0], t[9], t[14], t[3], t[4], t[13], t[2], t[7], t[8]
    	]);
    	t.set(tmp);
    }

    function lfsr2(t) {
    	for (let i = 0; i < stkSize; i++) {
    		const x = t[i];

    		const x7 = x >> 7;
    		const x5 = (x >> 5) & 1;
    		t[i] = (x << 1) | (x7 ^ x5);
    	}
    }

    function lfsr3(t) {
    	for (let i = 0; i < stkSize; i++) {
    		const x = t[i];

    		const x0 = x & 1;
    		const x6 = (x >> 6) & 1;
    		t[i] = (x >> 1) | ((x0 ^ x6) << 7);
    	}
    }

    function xorRC(t, i) {
    	t[0] ^= 1;
    	t[1] ^= 2;
    	t[2] ^= 4;
    	t[3] ^= 8;
    	t[4] ^= rcons[i];
    	t[5] ^= rcons[i];
    	t[6] ^= rcons[i];
    	t[7] ^= rcons[i];
    }

    function stkDeriveK(key, derivedKs) {
    	let tk2 = key.subarray(16, 32);
    	let tk3	= key.subarray(0, 16);

    	xorBytes(derivedKs[0], tk2, tk3, stkSize);
    	xorRC(derivedKs[0], 0);

    	for (let i = 1; i <= rounds; i++) {
    		lfsr2(tk2);
    		h(tk2);
    		lfsr3(tk3);
    		h(tk3);

    		xorBytes(derivedKs[i], tk2, tk3, stkSize);
    		xorRC(derivedKs[i], i);
    	}
    }

    function deriveSubTweakKeys(stks, derivedKs, tweak) {
    	let tk1 = new Uint8Array(tweak);

    	xorBytes(stks[0], derivedKs[0], tk1, stkSize);

    	for (let i = 1; i <= rounds; i++) {
    		h(tk1);
    		xorBytes(stks[i], derivedKs[i], tk1, stkSize);
    	}
    }

    function newStks() {
    	let stks = [];
    	for (let i = 0; i <= rounds; i++) {
    		stks.push(new Uint8Array(16));
    	}
    	return stks;
    }

    //
    // Deoxys-BC-384
    //

    class implCt32 {
    	static bcEncrypt(ciphertext, derivedKs, tweak, plaintext) {
    		let stks = newStks();
    		deriveSubTweakKeys(stks, derivedKs, tweak);

    		let q = aes.newQ(), stk = aes.newQ();
    		aes.load4xU32(q, plaintext);
    		aes.load4xU32(stk, stks[0]);
    		aes.addRoundKey(q, stk);

    		for (let i = 1; i <= rounds; i++) {
    			aes.subBytes(q);
    			aes.shiftRows(q);
    			aes.mixColumns(q);

    			aes.load4xU32(stk, stks[i]);
    			aes.addRoundKey(q, stk);
    		}

    		aes.store4xU32(ciphertext, q);
    	}

    	static bcKeystreamx2(ciphertext, derivedKs, tweaks, nonce) {
    		let stks = [ newStks(), newStks() ];
    		for (let i = 0; i < 2; i++) {
    			deriveSubTweakKeys(stks[i], derivedKs, tweaks[i]);
    		}

    		let q = aes.newQ(), stk = aes.newQ();
    		aes.rkeyOrtho(q, nonce);
    		aes.load8xU32(stk, stks[0][0], stks[1][0]);
    		aes.addRoundKey(q, stk);

    		for (let i = 1; i <= rounds; i++) {
    			aes.subBytes(q);
    			aes.shiftRows(q);
    			aes.mixColumns(q);

    			aes.load8xU32(stk, stks[0][i], stks[1][i]);
    			aes.addRoundKey(q, stk);
    		}
    		aes.store8xU32(ciphertext.subarray(0, 16), ciphertext.subarray(16, 32), q);
    	}

    	static bcTagx1(tag, derivedKs, tweak, plaintext) {
    		let stks = newStks();
    		deriveSubTweakKeys(stks, derivedKs, tweak);

    		let q = aes.newQ(), stk = aes.newQ();
    		aes.load4xU32(q, plaintext);
    		aes.load4xU32(stk, stks[0]);
    		aes.addRoundKey(q, stk);

    		for (let i = 1; i <= rounds; i++) {
    			aes.subBytes(q);
    			aes.shiftRows(q);
    			aes.mixColumns(q);

    			aes.load4xU32(stk, stks[i]);
    			aes.addRoundKey(q, stk);
    		}

    		const tagView = new DataView(tag.buffer);
    		let tag0 = tagView.getUint32(0, true);
    		let tag1 = tagView.getUint32(4, true);
    		let tag2 = tagView.getUint32(8, true);
    		let tag3 = tagView.getUint32(12, true);

    		aes.ortho(q);
    		tag0 = uint32.xor(tag0, q[0]);
    		tag1 = uint32.xor(tag1, q[2]);
    		tag2 = uint32.xor(tag2, q[4]);
    		tag3 = uint32.xor(tag3, q[6]);

    		tagView.setUint32(0, tag0, true);
    		tagView.setUint32(4, tag1, true);
    		tagView.setUint32(8, tag2, true);
    		tagView.setUint32(12, tag3, true);
    	}

    	static bcTagx2(tag, derivedKs, tweaks, plaintext) {
    		let stks = [ newStks(), newStks() ];
    		for (let i = 0; i < 2; i++) {
    			deriveSubTweakKeys(stks[i], derivedKs, tweaks[i]);
    		}

    		let q = aes.newQ(), stk = aes.newQ();
    		aes.load8xU32(q, plaintext.subarray(0, 16), plaintext.subarray(16, 32));
    		aes.load8xU32(stk, stks[0][0], stks[1][0]);
    		aes.addRoundKey(q, stk);

    		for (let i = 1; i <= rounds; i++) {
    			aes.subBytes(q);
    			aes.shiftRows(q);
    			aes.mixColumns(q);

    			aes.load8xU32(stk, stks[0][i], stks[1][i]);
    			aes.addRoundKey(q, stk);
    		}

    		const tagView = new DataView(tag.buffer);
    		let tag0 = tagView.getUint32(0, true);
    		let tag1 = tagView.getUint32(4, true);
    		let tag2 = tagView.getUint32(8, true);
    		let tag3 = tagView.getUint32(12, true);

    		aes.ortho(q);
    		tag0 = uint32.xor(tag0, q[0], q[1]);
    		tag1 = uint32.xor(tag1, q[2], q[3]);
    		tag2 = uint32.xor(tag2, q[4], q[5]);
    		tag3 = uint32.xor(tag3, q[6], q[7]);

    		tagView.setUint32(0, tag0, true);
    		tagView.setUint32(4, tag1, true);
    		tagView.setUint32(8, tag2, true);
    		tagView.setUint32(12, tag3, true);
    	}
    }

    class implUnsafeVartime {
    	static bcEncrypt(ciphertext, derivedKs, tweak, plaintext) {
    		let stks = newStks();
    		deriveSubTweakKeys(stks, derivedKs, tweak);

    		const plainView = new DataView(plaintext.buffer);
    		let s0 = plainView.getUint32(0 + plaintext.byteOffset, false);
    		let s1 = plainView.getUint32(4 + plaintext.byteOffset, false);
    		let s2 = plainView.getUint32(8 + plaintext.byteOffset, false);
    		let s3 = plainView.getUint32(12 + plaintext.byteOffset, false);


    		const stksView = new DataView(stks[0].buffer);
    		s0 = uint32.xor(s0, stksView.getUint32(0 + stks[0].byteOffset, false));
    		s1 = uint32.xor(s1, stksView.getUint32(4 + stks[0].byteOffset, false));
    		s2 = uint32.xor(s2, stksView.getUint32(8 + stks[0].byteOffset, false));
    		s3 = uint32.xor(s3, stksView.getUint32(12 + stks[0].byteOffset, false));

    		for (let i = 1; i <= rounds; i++) {
    			[s0, s1, s2, s3] = unsafe.aesencVartime(s0, s1, s2, s3, stks[i]);
    		}

    		const cipherView = new DataView(ciphertext.buffer);
    		cipherView.setUint32(0 + ciphertext.byteOffset, s0, false);
    		cipherView.setUint32(4 + ciphertext.byteOffset, s1, false);
    		cipherView.setUint32(8 + ciphertext.byteOffset, s2, false);
    		cipherView.setUint32(12 + ciphertext.byteOffset, s3, false);
    	}

    	static bcKeystreamx2(ciphertext, derivedKs, tweaks, nonce) {
    		this.bcEncrypt(ciphertext.subarray(0, 16), derivedKs, tweaks[0], nonce);
    		this.bcEncrypt(ciphertext.subarray(16, 32), derivedKs, tweaks[1], nonce);
    	}

    	static bcTagx1(tag, derivedKs, tweak, plaintext) {
    		let tmp = new Uint8Array(blockSize);
    		this.bcEncrypt(tmp, derivedKs, tweak, plaintext);
    		xorBytes(tag, tag, tmp, blockSize);
    	}

    	static bcTagx2(tag, derivedKs, tweaks, plaintext) {
    		let tmp = new Uint8Array(2*blockSize);
    		this.bcEncrypt(tmp.subarray(0, 16), derivedKs, tweaks[0], plaintext.subarray(0, 16));
    		this.bcEncrypt(tmp.subarray(16, 32), derivedKs, tweaks[1], plaintext.subarray(16, 32));
    		xorBytes(tag, tag, tmp.subarray(0, 16), blockSize);
    		xorBytes(tag, tag, tmp.subarray(16, 32), blockSize);
    	}
    }

    //
    // Put it all together
    //

    function encodeTagTweak(out, prefix, blockNr) {
    	out.set(new Uint8Array(12));
    	new DataView(out.buffer).setUint32(12 + out.byteOffset, blockNr, false);
    	out[0] = prefix << prefixShift;
    }

    function encodeEncTweak(out, tag, blockNr) {
    	var tmp = new Uint8Array(4);
    	new DataView(tmp.buffer).setUint32(0, blockNr, false);

    	out.set(tag);
    	out[0] |= 0x80;

    	xorBytes(out.subarray(12, 16), out.subarray(12, 16), tmp, 4);
    }

    function newTweaks() {
    	let tweaks = [];
    	for (let i = 0; i < 2; i++) {
    		tweaks.push(new Uint8Array(tweakSize));
    	}
    	return tweaks;
    }

    function e(impl, derivedKs, nonce, dst, ad, msg) {
    	let tweaks = newTweaks();
    	let i = 0, j = 0;

    	// Associated data.
    	let adLen = ad.length;
    	let auth = new Uint8Array(TagSize);
    	for (i = 0; adLen >= 2*blockSize; i += 2) {
    		encodeTagTweak(tweaks[0], prefixADBlock, i);
    		encodeTagTweak(tweaks[1], prefixADBlock, i+1);
    		impl.bcTagx2(auth, derivedKs, tweaks, ad.subarray(i*blockSize, (i+2)*blockSize));

    		adLen -= 2*blockSize;
    	}
    	for (; adLen >= blockSize; i++) {
    		encodeTagTweak(tweaks[0], prefixADBlock, i);
    		impl.bcTagx1(auth, derivedKs, tweaks[0], ad.subarray(i*blockSize, (i+1)*blockSize));

    		adLen -= blockSize;
    	}
    	if (adLen > 0) {
    		encodeTagTweak(tweaks[0], prefixADFinal, i);

    		let aStar = new Uint8Array(blockSize);
    		aStar.set(ad.subarray(ad.length - adLen));
    		aStar[adLen] = 0x80;

    		impl.bcTagx1(auth, derivedKs, tweaks[0], aStar);
    	}

    	// Message authentication and tag generation.
    	let msgLen = msg.length;
    	for (j = 0; msgLen >= 2*blockSize; j += 2) {
    		encodeTagTweak(tweaks[0], prefixMsgBlock, j);
    		encodeTagTweak(tweaks[1], prefixMsgBlock, j+1);
    		impl.bcTagx2(auth, derivedKs, tweaks, msg.subarray(j*blockSize, (j+2)*blockSize));

    		msgLen -= 2*blockSize;
    	}
    	for (; msgLen >= blockSize; j++) {
    		encodeTagTweak(tweaks[0], prefixMsgBlock, j);
    		impl.bcTagx1(auth, derivedKs, tweaks[0], msg.subarray(j*blockSize, (j+1)*blockSize));

    		msgLen -= blockSize;
    	}
    	if (msgLen > 0) {
    		encodeTagTweak(tweaks[0], prefixMsgFinal, j);

    		let mStar = new Uint8Array(blockSize);
    		mStar.set(msg.subarray(msg.length - msgLen));
    		mStar[msgLen] = 0x80;

    		impl.bcTagx1(auth, derivedKs, tweaks[0], mStar);
    	}

    	// Generate the tag.
    	let encNonce = new Uint8Array(blockSize);
    	encNonce.set(nonce, 1);
    	encNonce[0] = prefixTag << prefixShift;
    	impl.bcEncrypt(auth, derivedKs, encNonce, auth);

    	// Message encryption.
    	encNonce[0] = 0;
    	msgLen = msg.length;
    	let encBlks = new Uint8Array(2*blockSize);
    	for (j = 0; msgLen >= 2*blockSize; j += 2) {
    		encodeEncTweak(tweaks[0], auth, j);
    		encodeEncTweak(tweaks[1], auth, j+1);

    		impl.bcKeystreamx2(encBlks, derivedKs, tweaks, encNonce);
    		xorBytes(dst.subarray(j*blockSize, (j+2)*blockSize), msg.subarray(j*blockSize, (j+2)*blockSize), encBlks, 2*blockSize);

    		msgLen -= 2*blockSize;
    	}
    	for (; msgLen >= blockSize; j++) {
    		encodeEncTweak(tweaks[0], auth, j);
    		impl.bcEncrypt(encBlks, derivedKs, tweaks[0], encNonce);
    		xorBytes(dst.subarray(j*blockSize, (j+1)*blockSize), msg.subarray(j*blockSize, (j+1)*blockSize), encBlks, blockSize);

    		msgLen -= blockSize;
    	}
    	if (msgLen > 0) {
    		encodeEncTweak(tweaks[0], auth, j);

    		impl.bcEncrypt(encBlks, derivedKs, tweaks[0], encNonce);
    		xorBytes(dst.subarray(j*blockSize, msg.length), msg.subarray(j*blockSize), encBlks, msgLen);
    	}

    	// Write the tag to the tail.
    	dst.set(auth, msg.length);
    }

    function d(impl, derivedKs, nonce, dst, ad, ct) {
    	let ctLen = ct.length - TagSize;
    	const ciphertext = ct.subarray(0, ctLen);
    	const tag = ct.subarray(ctLen);

    	// Message decryption.
    	let j = 0;
    	let decTweaks = newTweaks();
    	let decNonce = new Uint8Array(blockSize);
    	decNonce.set(nonce, 1);
    	let decBlks = new Uint8Array(2*blockSize);
    	for (j = 0; ctLen >= 2*blockSize; j+=2) {
    		encodeEncTweak(decTweaks[0], tag, j);
    		encodeEncTweak(decTweaks[1], tag, j+1);

    		impl.bcKeystreamx2(decBlks, derivedKs, decTweaks, decNonce);
    		xorBytes(dst.subarray(j*blockSize, (j+2)*blockSize), ciphertext.subarray(j*blockSize, (j+2)*blockSize), decBlks, 2*blockSize);

    		ctLen -= 2*blockSize;
    	}
    	for (; ctLen >= blockSize; j++) {
    		encodeEncTweak(decTweaks[0], tag, j);

    		impl.bcEncrypt(decBlks, derivedKs, decTweaks[0], decNonce);
    		xorBytes(dst.subarray(j*blockSize, (j+1)*blockSize), ciphertext.subarray(j*blockSize, (j+1)*blockSize), decBlks, blockSize);

    		ctLen -= blockSize;
    	}
    	if (ctLen > 0) {
    		encodeEncTweak(decTweaks[0], tag, j);

    		impl.bcEncrypt(decBlks, derivedKs, decTweaks[0], decNonce);
    		xorBytes(dst.subarray(j*blockSize), ciphertext.subarray(j*blockSize), decBlks, ctLen);
    	}

    	// Associated data.
    	let i = 0;
    	let adLen = ad.length;
    	let tweaks = newTweaks();
    	let auth = new Uint8Array(TagSize);
    	for (i = 0; adLen >= 2*blockSize; i += 2) {
    		encodeTagTweak(tweaks[0], prefixADBlock, i);
    		encodeTagTweak(tweaks[1], prefixADBlock, i+1);
    		impl.bcTagx2(auth, derivedKs, tweaks, ad.subarray(i*blockSize, (i+2)*blockSize));

    		adLen -= 2*blockSize;
    	}
    	for (; adLen >= blockSize; i++) {
    		encodeTagTweak(tweaks[0], prefixADBlock, i);
    		impl.bcTagx1(auth, derivedKs, tweaks[0], ad.subarray(i*blockSize, (i+1)*blockSize));

    		adLen -= blockSize;
    	}
    	if (adLen > 0) {
    		encodeTagTweak(tweaks[0], prefixADFinal, i);

    		let aStar = new Uint8Array(blockSize);

    		aStar.set(ad.subarray(ad.length - adLen));
    		aStar[adLen] = 0x80;

    		impl.bcTagx1(auth, derivedKs, tweaks[0], aStar);
    	}

    	// Message authentication and tag generation.
    	let msgLen = dst.length;
    	for (j = 0; msgLen >= 2*blockSize; j += 2) {
    		encodeTagTweak(tweaks[0], prefixMsgBlock, j);
    		encodeTagTweak(tweaks[1], prefixMsgBlock, j+1);
    		impl.bcTagx2(auth, derivedKs, tweaks, dst.subarray(j*blockSize, (j+2)*blockSize));

    		msgLen -= 2*blockSize;
    	}
    	for (; msgLen >= blockSize; j++) {
    		encodeTagTweak(tweaks[0], prefixMsgBlock, j);
    		impl.bcTagx1(auth, derivedKs, tweaks[0], dst.subarray(j*blockSize, (j+1)*blockSize));

    		msgLen -= blockSize;
    	}
    	if (msgLen > 0) {
    		encodeTagTweak(tweaks[0], prefixMsgFinal, j);

    		let mStar = new Uint8Array(blockSize);
    		mStar.set(dst.subarray(dst.length - msgLen));
    		mStar[msgLen] = 0x80;

    		impl.bcTagx1(auth, derivedKs, tweaks[0], mStar);
    	}

    	decNonce[0] = prefixTag << prefixShift;
    	impl.bcEncrypt(auth, derivedKs, decNonce, auth);

    	// crypto.timingSafeEqual is not implemented on typed arrays.
    	if (auth.length != tag.length) {
    		return false;
    	}
    	let eql = true;
    	for (i = 0; i < auth.length; i++) {
    		eql &= !(auth[i] ^ tag[i]);
    	}

    	return eql;
    }

    // The AEAD implementation.
    //
    // As much as possible (as long as the key does not change), instances should
    // be reused as deriving the K contribution of the Sub-Tweak Key is relatively
    // expensive.
    class AEAD {
    	constructor(key, useUnsafeVartime = false) {
    		if (key.length != KeySize) {
    			throw ErrKeySize;
    		}

    		if (useUnsafeVartime) {
    			this.impl = implUnsafeVartime;
    		} else {
    			this.impl = implCt32;
    		}
    		this.derivedKs = newStks();
    		stkDeriveK(key, this.derivedKs);
    	}

    	encrypt(nonce, plaintext = null, associatedData = null) {
    		if (nonce.length != NonceSize) {
    			throw ErrNonceSize;
    		}

    		if (plaintext == null) {
    			plaintext = zeroBuffer;
    		}
    		if (associatedData == null) {
    			associatedData = zeroBuffer;
    		}

    		let dst = new Uint8Array(plaintext.length + TagSize);
    		e(this.impl, this.derivedKs, nonce, dst, associatedData, plaintext);

    		return dst;
    	}

    	decrypt(nonce, ciphertext, associatedData) {
    		if (nonce.length != NonceSize) {
    			throw ErrNonceSize;
    		}
    		if (ciphertext.length < TagSize) {
    			throw ErrOpen;
    		}

    		if (associatedData == null) {
    			associatedData = zeroBuffer;
    		}

    		let dst = new Uint8Array(ciphertext.length - TagSize);
    		if (!d(this.impl, this.derivedKs, nonce, dst, associatedData, ciphertext)) {
    			dst.set(new Uint8Array(dst.length));
    			throw ErrOpen;
    		}

    		return dst;
    	}
    }

    const zeroBuffer = new Uint8Array(0);

    const ErrKeySize = 'deoxysii: invalid key size';
    const ErrNonceSize = 'deoxysii: invalid nonce size';
    const ErrOpen = 'deoxysii: message authentication failure';

    var deoxysii = {
    	KeySize: KeySize,
    	NonceSize: NonceSize,
    	TagSize: TagSize,

    	ErrNonceSize: ErrNonceSize,
    	ErrKeySize: ErrKeySize,
    	ErrOpen: ErrOpen,

    	AEAD: AEAD,
    };
    var deoxysii_1 = deoxysii.KeySize;
    var deoxysii_2 = deoxysii.NonceSize;
    var deoxysii_7 = deoxysii.AEAD;

    var require$$0 = {};

    var naclFast = createCommonjsModule$1(function (module) {
    (function(nacl) {

    // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
    // Public domain.
    //
    // Implementation derived from TweetNaCl version 20140427.
    // See for details: http://tweetnacl.cr.yp.to/

    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
      return r;
    };

    //  Pluggable, initialized in high-level API below.
    var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32); _9[0] = 9;

    var gf0 = gf(),
        gf1 = gf([1]),
        _121665 = gf([0xdb41, 1]),
        D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
        D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
        X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
        Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
        I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

    function ts64(x, i, h, l) {
      x[i]   = (h >> 24) & 0xff;
      x[i+1] = (h >> 16) & 0xff;
      x[i+2] = (h >>  8) & 0xff;
      x[i+3] = h & 0xff;
      x[i+4] = (l >> 24)  & 0xff;
      x[i+5] = (l >> 16)  & 0xff;
      x[i+6] = (l >>  8)  & 0xff;
      x[i+7] = l & 0xff;
    }

    function vn(x, xi, y, yi, n) {
      var i,d = 0;
      for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
      return (1 & ((d - 1) >>> 8)) - 1;
    }

    function crypto_verify_16(x, xi, y, yi) {
      return vn(x,xi,y,yi,16);
    }

    function crypto_verify_32(x, xi, y, yi) {
      return vn(x,xi,y,yi,32);
    }

    function core_salsa20(o, p, k, c) {
      var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
          j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
          j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
          j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
          j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
          j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
          j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
          j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
          j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
          j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
          j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
          j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
          j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
          j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
          j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
          j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
          x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
          x15 = j15, u;

      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u<<7 | u>>>(32-7);
        u = x4 + x0 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x4 | 0;
        x12 ^= u<<13 | u>>>(32-13);
        u = x12 + x8 | 0;
        x0 ^= u<<18 | u>>>(32-18);

        u = x5 + x1 | 0;
        x9 ^= u<<7 | u>>>(32-7);
        u = x9 + x5 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x9 | 0;
        x1 ^= u<<13 | u>>>(32-13);
        u = x1 + x13 | 0;
        x5 ^= u<<18 | u>>>(32-18);

        u = x10 + x6 | 0;
        x14 ^= u<<7 | u>>>(32-7);
        u = x14 + x10 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x14 | 0;
        x6 ^= u<<13 | u>>>(32-13);
        u = x6 + x2 | 0;
        x10 ^= u<<18 | u>>>(32-18);

        u = x15 + x11 | 0;
        x3 ^= u<<7 | u>>>(32-7);
        u = x3 + x15 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x3 | 0;
        x11 ^= u<<13 | u>>>(32-13);
        u = x11 + x7 | 0;
        x15 ^= u<<18 | u>>>(32-18);

        u = x0 + x3 | 0;
        x1 ^= u<<7 | u>>>(32-7);
        u = x1 + x0 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x1 | 0;
        x3 ^= u<<13 | u>>>(32-13);
        u = x3 + x2 | 0;
        x0 ^= u<<18 | u>>>(32-18);

        u = x5 + x4 | 0;
        x6 ^= u<<7 | u>>>(32-7);
        u = x6 + x5 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x6 | 0;
        x4 ^= u<<13 | u>>>(32-13);
        u = x4 + x7 | 0;
        x5 ^= u<<18 | u>>>(32-18);

        u = x10 + x9 | 0;
        x11 ^= u<<7 | u>>>(32-7);
        u = x11 + x10 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x11 | 0;
        x9 ^= u<<13 | u>>>(32-13);
        u = x9 + x8 | 0;
        x10 ^= u<<18 | u>>>(32-18);

        u = x15 + x14 | 0;
        x12 ^= u<<7 | u>>>(32-7);
        u = x12 + x15 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x12 | 0;
        x14 ^= u<<13 | u>>>(32-13);
        u = x14 + x13 | 0;
        x15 ^= u<<18 | u>>>(32-18);
      }
       x0 =  x0 +  j0 | 0;
       x1 =  x1 +  j1 | 0;
       x2 =  x2 +  j2 | 0;
       x3 =  x3 +  j3 | 0;
       x4 =  x4 +  j4 | 0;
       x5 =  x5 +  j5 | 0;
       x6 =  x6 +  j6 | 0;
       x7 =  x7 +  j7 | 0;
       x8 =  x8 +  j8 | 0;
       x9 =  x9 +  j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;

      o[ 0] = x0 >>>  0 & 0xff;
      o[ 1] = x0 >>>  8 & 0xff;
      o[ 2] = x0 >>> 16 & 0xff;
      o[ 3] = x0 >>> 24 & 0xff;

      o[ 4] = x1 >>>  0 & 0xff;
      o[ 5] = x1 >>>  8 & 0xff;
      o[ 6] = x1 >>> 16 & 0xff;
      o[ 7] = x1 >>> 24 & 0xff;

      o[ 8] = x2 >>>  0 & 0xff;
      o[ 9] = x2 >>>  8 & 0xff;
      o[10] = x2 >>> 16 & 0xff;
      o[11] = x2 >>> 24 & 0xff;

      o[12] = x3 >>>  0 & 0xff;
      o[13] = x3 >>>  8 & 0xff;
      o[14] = x3 >>> 16 & 0xff;
      o[15] = x3 >>> 24 & 0xff;

      o[16] = x4 >>>  0 & 0xff;
      o[17] = x4 >>>  8 & 0xff;
      o[18] = x4 >>> 16 & 0xff;
      o[19] = x4 >>> 24 & 0xff;

      o[20] = x5 >>>  0 & 0xff;
      o[21] = x5 >>>  8 & 0xff;
      o[22] = x5 >>> 16 & 0xff;
      o[23] = x5 >>> 24 & 0xff;

      o[24] = x6 >>>  0 & 0xff;
      o[25] = x6 >>>  8 & 0xff;
      o[26] = x6 >>> 16 & 0xff;
      o[27] = x6 >>> 24 & 0xff;

      o[28] = x7 >>>  0 & 0xff;
      o[29] = x7 >>>  8 & 0xff;
      o[30] = x7 >>> 16 & 0xff;
      o[31] = x7 >>> 24 & 0xff;

      o[32] = x8 >>>  0 & 0xff;
      o[33] = x8 >>>  8 & 0xff;
      o[34] = x8 >>> 16 & 0xff;
      o[35] = x8 >>> 24 & 0xff;

      o[36] = x9 >>>  0 & 0xff;
      o[37] = x9 >>>  8 & 0xff;
      o[38] = x9 >>> 16 & 0xff;
      o[39] = x9 >>> 24 & 0xff;

      o[40] = x10 >>>  0 & 0xff;
      o[41] = x10 >>>  8 & 0xff;
      o[42] = x10 >>> 16 & 0xff;
      o[43] = x10 >>> 24 & 0xff;

      o[44] = x11 >>>  0 & 0xff;
      o[45] = x11 >>>  8 & 0xff;
      o[46] = x11 >>> 16 & 0xff;
      o[47] = x11 >>> 24 & 0xff;

      o[48] = x12 >>>  0 & 0xff;
      o[49] = x12 >>>  8 & 0xff;
      o[50] = x12 >>> 16 & 0xff;
      o[51] = x12 >>> 24 & 0xff;

      o[52] = x13 >>>  0 & 0xff;
      o[53] = x13 >>>  8 & 0xff;
      o[54] = x13 >>> 16 & 0xff;
      o[55] = x13 >>> 24 & 0xff;

      o[56] = x14 >>>  0 & 0xff;
      o[57] = x14 >>>  8 & 0xff;
      o[58] = x14 >>> 16 & 0xff;
      o[59] = x14 >>> 24 & 0xff;

      o[60] = x15 >>>  0 & 0xff;
      o[61] = x15 >>>  8 & 0xff;
      o[62] = x15 >>> 16 & 0xff;
      o[63] = x15 >>> 24 & 0xff;
    }

    function core_hsalsa20(o,p,k,c) {
      var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
          j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
          j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
          j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
          j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
          j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
          j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
          j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
          j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
          j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
          j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
          j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
          j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
          j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
          j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
          j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
          x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
          x15 = j15, u;

      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u<<7 | u>>>(32-7);
        u = x4 + x0 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x4 | 0;
        x12 ^= u<<13 | u>>>(32-13);
        u = x12 + x8 | 0;
        x0 ^= u<<18 | u>>>(32-18);

        u = x5 + x1 | 0;
        x9 ^= u<<7 | u>>>(32-7);
        u = x9 + x5 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x9 | 0;
        x1 ^= u<<13 | u>>>(32-13);
        u = x1 + x13 | 0;
        x5 ^= u<<18 | u>>>(32-18);

        u = x10 + x6 | 0;
        x14 ^= u<<7 | u>>>(32-7);
        u = x14 + x10 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x14 | 0;
        x6 ^= u<<13 | u>>>(32-13);
        u = x6 + x2 | 0;
        x10 ^= u<<18 | u>>>(32-18);

        u = x15 + x11 | 0;
        x3 ^= u<<7 | u>>>(32-7);
        u = x3 + x15 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x3 | 0;
        x11 ^= u<<13 | u>>>(32-13);
        u = x11 + x7 | 0;
        x15 ^= u<<18 | u>>>(32-18);

        u = x0 + x3 | 0;
        x1 ^= u<<7 | u>>>(32-7);
        u = x1 + x0 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x1 | 0;
        x3 ^= u<<13 | u>>>(32-13);
        u = x3 + x2 | 0;
        x0 ^= u<<18 | u>>>(32-18);

        u = x5 + x4 | 0;
        x6 ^= u<<7 | u>>>(32-7);
        u = x6 + x5 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x6 | 0;
        x4 ^= u<<13 | u>>>(32-13);
        u = x4 + x7 | 0;
        x5 ^= u<<18 | u>>>(32-18);

        u = x10 + x9 | 0;
        x11 ^= u<<7 | u>>>(32-7);
        u = x11 + x10 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x11 | 0;
        x9 ^= u<<13 | u>>>(32-13);
        u = x9 + x8 | 0;
        x10 ^= u<<18 | u>>>(32-18);

        u = x15 + x14 | 0;
        x12 ^= u<<7 | u>>>(32-7);
        u = x12 + x15 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x12 | 0;
        x14 ^= u<<13 | u>>>(32-13);
        u = x14 + x13 | 0;
        x15 ^= u<<18 | u>>>(32-18);
      }

      o[ 0] = x0 >>>  0 & 0xff;
      o[ 1] = x0 >>>  8 & 0xff;
      o[ 2] = x0 >>> 16 & 0xff;
      o[ 3] = x0 >>> 24 & 0xff;

      o[ 4] = x5 >>>  0 & 0xff;
      o[ 5] = x5 >>>  8 & 0xff;
      o[ 6] = x5 >>> 16 & 0xff;
      o[ 7] = x5 >>> 24 & 0xff;

      o[ 8] = x10 >>>  0 & 0xff;
      o[ 9] = x10 >>>  8 & 0xff;
      o[10] = x10 >>> 16 & 0xff;
      o[11] = x10 >>> 24 & 0xff;

      o[12] = x15 >>>  0 & 0xff;
      o[13] = x15 >>>  8 & 0xff;
      o[14] = x15 >>> 16 & 0xff;
      o[15] = x15 >>> 24 & 0xff;

      o[16] = x6 >>>  0 & 0xff;
      o[17] = x6 >>>  8 & 0xff;
      o[18] = x6 >>> 16 & 0xff;
      o[19] = x6 >>> 24 & 0xff;

      o[20] = x7 >>>  0 & 0xff;
      o[21] = x7 >>>  8 & 0xff;
      o[22] = x7 >>> 16 & 0xff;
      o[23] = x7 >>> 24 & 0xff;

      o[24] = x8 >>>  0 & 0xff;
      o[25] = x8 >>>  8 & 0xff;
      o[26] = x8 >>> 16 & 0xff;
      o[27] = x8 >>> 24 & 0xff;

      o[28] = x9 >>>  0 & 0xff;
      o[29] = x9 >>>  8 & 0xff;
      o[30] = x9 >>> 16 & 0xff;
      o[31] = x9 >>> 24 & 0xff;
    }

    function crypto_core_salsa20(out,inp,k,c) {
      core_salsa20(out,inp,k,c);
    }

    function crypto_core_hsalsa20(out,inp,k,c) {
      core_hsalsa20(out,inp,k,c);
    }

    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
                // "expand 32-byte k"

    function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z[i] = 0;
      for (i = 0; i < 8; i++) z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 0xff) | 0;
          z[i] = u & 0xff;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
      }
      return 0;
    }

    function crypto_stream_salsa20(c,cpos,b,n,k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z[i] = 0;
      for (i = 0; i < 8; i++) z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < 64; i++) c[cpos+i] = x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 0xff) | 0;
          z[i] = u & 0xff;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < b; i++) c[cpos+i] = x[i];
      }
      return 0;
    }

    function crypto_stream(c,cpos,d,n,k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s,n,k,sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i+16];
      return crypto_stream_salsa20(c,cpos,d,sn,s);
    }

    function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s,n,k,sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i+16];
      return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
    }

    /*
    * Port of Andrew Moon's Poly1305-donna-16. Public domain.
    * https://github.com/floodyberry/poly1305-donna
    */

    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;

      var t0, t1, t2, t3, t4, t5, t6, t7;

      t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
      t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
      t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
      t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
      t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
      this.r[5] = ((t4 >>>  1)) & 0x1ffe;
      t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
      t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
      t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
      this.r[9] = ((t7 >>>  5)) & 0x007f;

      this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
      this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
      this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
      this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
      this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
      this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
      this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
      this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
    };

    poly1305.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : (1 << 11);
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

      var h0 = this.h[0],
          h1 = this.h[1],
          h2 = this.h[2],
          h3 = this.h[3],
          h4 = this.h[4],
          h5 = this.h[5],
          h6 = this.h[6],
          h7 = this.h[7],
          h8 = this.h[8],
          h9 = this.h[9];

      var r0 = this.r[0],
          r1 = this.r[1],
          r2 = this.r[2],
          r3 = this.r[3],
          r4 = this.r[4],
          r5 = this.r[5],
          r6 = this.r[6],
          r7 = this.r[7],
          r8 = this.r[8],
          r9 = this.r[9];

      while (bytes >= 16) {
        t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
        t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
        t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
        t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
        t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
        h5 += ((t4 >>>  1)) & 0x1fff;
        t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
        t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
        t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
        h9 += ((t7 >>> 5)) | hibit;

        c = 0;

        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = (d0 >>> 13); d0 &= 0x1fff;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += (d0 >>> 13); d0 &= 0x1fff;

        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = (d1 >>> 13); d1 &= 0x1fff;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += (d1 >>> 13); d1 &= 0x1fff;

        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = (d2 >>> 13); d2 &= 0x1fff;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += (d2 >>> 13); d2 &= 0x1fff;

        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = (d3 >>> 13); d3 &= 0x1fff;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += (d3 >>> 13); d3 &= 0x1fff;

        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = (d4 >>> 13); d4 &= 0x1fff;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += (d4 >>> 13); d4 &= 0x1fff;

        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = (d5 >>> 13); d5 &= 0x1fff;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += (d5 >>> 13); d5 &= 0x1fff;

        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = (d6 >>> 13); d6 &= 0x1fff;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += (d6 >>> 13); d6 &= 0x1fff;

        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = (d7 >>> 13); d7 &= 0x1fff;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += (d7 >>> 13); d7 &= 0x1fff;

        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = (d8 >>> 13); d8 &= 0x1fff;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += (d8 >>> 13); d8 &= 0x1fff;

        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = (d9 >>> 13); d9 &= 0x1fff;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += (d9 >>> 13); d9 &= 0x1fff;

        c = (((c << 2) + c)) | 0;
        c = (c + d0) | 0;
        d0 = c & 0x1fff;
        c = (c >>> 13);
        d1 += c;

        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;

        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };

    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f, i;

      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++) this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }

      c = this.h[1] >>> 13;
      this.h[1] &= 0x1fff;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 0x1fff;
      }
      this.h[0] += (c * 5);
      c = this.h[0] >>> 13;
      this.h[0] &= 0x1fff;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 0x1fff;
      this.h[2] += c;

      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 0x1fff;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 0x1fff;
      }
      g[9] -= (1 << 13);

      mask = (c ^ 1) - 1;
      for (i = 0; i < 10; i++) g[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

      this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
      this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
      this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
      this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
      this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
      this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
      this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
      this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

      f = this.h[0] + this.pad[0];
      this.h[0] = f & 0xffff;
      for (i = 1; i < 8; i++) {
        f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
        this.h[i] = f & 0xffff;
      }

      mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
      mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
      mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
      mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
      mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
      mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
      mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
      mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
      mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
      mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
      mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
      mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
      mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
      mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
      mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
      mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
    };

    poly1305.prototype.update = function(m, mpos, bytes) {
      var i, want;

      if (this.leftover) {
        want = (16 - this.leftover);
        if (want > bytes)
          want = bytes;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m[mpos+i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }

      if (bytes >= 16) {
        want = bytes - (bytes % 16);
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }

      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos+i];
        this.leftover += bytes;
      }
    };

    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly1305(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }

    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x,0,m,mpos,n,k);
      return crypto_verify_16(h,hpos,x,0);
    }

    function crypto_secretbox(c,m,d,n,k) {
      var i;
      if (d < 32) return -1;
      crypto_stream_xor(c,0,m,0,d,n,k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0; i < 16; i++) c[i] = 0;
      return 0;
    }

    function crypto_secretbox_open(m,c,d,n,k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32) return -1;
      crypto_stream(x,0,32,n,k);
      if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
      crypto_stream_xor(m,0,c,0,d,n,k);
      for (i = 0; i < 32; i++) m[i] = 0;
      return 0;
    }

    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++) r[i] = a[i]|0;
    }

    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c-1 + 37 * (c-1);
    }

    function sel25519(p, q, b) {
      var t, c = ~(b-1);
      for (var i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }

    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0; i < 16; i++) t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
          m[i-1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
        b = (m[15]>>16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1-b);
      }
      for (i = 0; i < 16; i++) {
        o[2*i] = t[i] & 0xff;
        o[2*i+1] = t[i]>>8;
      }
    }

    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }

    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }

    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
      o[15] &= 0x7fff;
    }

    function A(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
    }

    function Z(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
    }

    function M(o, a, b) {
      var v, c,
         t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
         t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
        t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
        t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
        b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11],
        b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];

      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;

      t0  += 38 * t16;
      t1  += 38 * t17;
      t2  += 38 * t18;
      t3  += 38 * t19;
      t4  += 38 * t20;
      t5  += 38 * t21;
      t6  += 38 * t22;
      t7  += 38 * t23;
      t8  += 38 * t24;
      t9  += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      // t15 left as is

      // first car
      c = 1;
      v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
      v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
      v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
      v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
      v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
      v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
      v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
      v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
      v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
      v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
      v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
      v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
      v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
      v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
      v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
      v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
      t0 += c-1 + 37 * (c-1);

      // second car
      c = 1;
      v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
      v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
      v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
      v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
      v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
      v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
      v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
      v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
      v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
      v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
      v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
      v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
      v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
      v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
      v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
      v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
      t0 += c-1 + 37 * (c-1);

      o[ 0] = t0;
      o[ 1] = t1;
      o[ 2] = t2;
      o[ 3] = t3;
      o[ 4] = t4;
      o[ 5] = t5;
      o[ 6] = t6;
      o[ 7] = t7;
      o[ 8] = t8;
      o[ 9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }

    function S(o, a) {
      M(o, a, a);
    }

    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if(a !== 2 && a !== 4) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }

    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 250; a >= 0; a--) {
          S(c, c);
          if(a !== 1) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }

    function crypto_scalarmult(q, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf(), b = gf(), c = gf(),
          d = gf(), e = gf(), f = gf();
      for (i = 0; i < 31; i++) z[i] = n[i];
      z[31]=(n[31]&127)|64;
      z[0]&=248;
      unpack25519(x,p);
      for (i = 0; i < 16; i++) {
        b[i]=x[i];
        d[i]=a[i]=c[i]=0;
      }
      a[0]=d[0]=1;
      for (i=254; i>=0; --i) {
        r=(z[i>>>3]>>>(i&7))&1;
        sel25519(a,b,r);
        sel25519(c,d,r);
        A(e,a,c);
        Z(a,a,c);
        A(c,b,d);
        Z(b,b,d);
        S(d,e);
        S(f,a);
        M(a,c,a);
        M(c,b,e);
        A(e,a,c);
        Z(a,a,c);
        S(b,a);
        Z(c,d,f);
        M(a,c,_121665);
        A(a,a,d);
        M(c,c,a);
        M(a,d,f);
        M(d,b,x);
        S(b,e);
        sel25519(a,b,r);
        sel25519(c,d,r);
      }
      for (i = 0; i < 16; i++) {
        x[i+16]=a[i];
        x[i+32]=c[i];
        x[i+48]=b[i];
        x[i+64]=d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32,x32);
      M(x16,x16,x32);
      pack25519(q,x16);
      return 0;
    }

    function crypto_scalarmult_base(q, n) {
      return crypto_scalarmult(q, n, _9);
    }

    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }

    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }

    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;

    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }

    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }

    var K = [
      0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
      0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
      0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
      0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
      0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
      0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
      0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
      0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
      0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
      0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
      0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
      0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
      0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
      0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
      0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
      0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
      0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
      0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
      0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
      0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
      0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
      0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
      0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
      0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
      0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
      0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
      0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
      0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
      0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
      0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
      0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
      0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
      0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
      0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
      0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
      0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
      0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
      0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
      0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
      0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
    ];

    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16),
          bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
          bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
          th, tl, i, j, h, l, a, b, c, d;

      var ah0 = hh[0],
          ah1 = hh[1],
          ah2 = hh[2],
          ah3 = hh[3],
          ah4 = hh[4],
          ah5 = hh[5],
          ah6 = hh[6],
          ah7 = hh[7],

          al0 = hl[0],
          al1 = hl[1],
          al2 = hl[2],
          al3 = hl[3],
          al4 = hl[4],
          al5 = hl[5],
          al6 = hl[6],
          al7 = hl[7];

      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
          wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;

          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;

          // add
          h = ah7;
          l = al7;

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          // Sigma1
          h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
          l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // Ch
          h = (ah4 & ah5) ^ (~ah4 & ah6);
          l = (al4 & al5) ^ (~al4 & al6);

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // K
          h = K[i*2];
          l = K[i*2+1];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // w
          h = wh[i%16];
          l = wl[i%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          th = c & 0xffff | d << 16;
          tl = a & 0xffff | b << 16;

          // add
          h = th;
          l = tl;

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          // Sigma0
          h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
          l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // Maj
          h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
          l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          bh7 = (c & 0xffff) | (d << 16);
          bl7 = (a & 0xffff) | (b << 16);

          // add
          h = bh3;
          l = bl3;

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = th;
          l = tl;

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          bh3 = (c & 0xffff) | (d << 16);
          bl3 = (a & 0xffff) | (b << 16);

          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;

          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;

          if (i%16 === 15) {
            for (j = 0; j < 16; j++) {
              // add
              h = wh[j];
              l = wl[j];

              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;

              h = wh[(j+9)%16];
              l = wl[(j+9)%16];

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              // sigma0
              th = wh[(j+1)%16];
              tl = wl[(j+1)%16];
              h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
              l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              // sigma1
              th = wh[(j+14)%16];
              tl = wl[(j+14)%16];
              h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
              l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;

              wh[j] = (c & 0xffff) | (d << 16);
              wl[j] = (a & 0xffff) | (b << 16);
            }
          }
        }

        // add
        h = ah0;
        l = al0;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[0];
        l = hl[0];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[0] = ah0 = (c & 0xffff) | (d << 16);
        hl[0] = al0 = (a & 0xffff) | (b << 16);

        h = ah1;
        l = al1;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[1];
        l = hl[1];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[1] = ah1 = (c & 0xffff) | (d << 16);
        hl[1] = al1 = (a & 0xffff) | (b << 16);

        h = ah2;
        l = al2;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[2];
        l = hl[2];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[2] = ah2 = (c & 0xffff) | (d << 16);
        hl[2] = al2 = (a & 0xffff) | (b << 16);

        h = ah3;
        l = al3;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[3];
        l = hl[3];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[3] = ah3 = (c & 0xffff) | (d << 16);
        hl[3] = al3 = (a & 0xffff) | (b << 16);

        h = ah4;
        l = al4;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[4];
        l = hl[4];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[4] = ah4 = (c & 0xffff) | (d << 16);
        hl[4] = al4 = (a & 0xffff) | (b << 16);

        h = ah5;
        l = al5;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[5];
        l = hl[5];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[5] = ah5 = (c & 0xffff) | (d << 16);
        hl[5] = al5 = (a & 0xffff) | (b << 16);

        h = ah6;
        l = al6;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[6];
        l = hl[6];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[6] = ah6 = (c & 0xffff) | (d << 16);
        hl[6] = al6 = (a & 0xffff) | (b << 16);

        h = ah7;
        l = al7;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[7];
        l = hl[7];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[7] = ah7 = (c & 0xffff) | (d << 16);
        hl[7] = al7 = (a & 0xffff) | (b << 16);

        pos += 128;
        n -= 128;
      }

      return n;
    }

    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8),
          hl = new Int32Array(8),
          x = new Uint8Array(256),
          i, b = n;

      hh[0] = 0x6a09e667;
      hh[1] = 0xbb67ae85;
      hh[2] = 0x3c6ef372;
      hh[3] = 0xa54ff53a;
      hh[4] = 0x510e527f;
      hh[5] = 0x9b05688c;
      hh[6] = 0x1f83d9ab;
      hh[7] = 0x5be0cd19;

      hl[0] = 0xf3bcc908;
      hl[1] = 0x84caa73b;
      hl[2] = 0xfe94f82b;
      hl[3] = 0x5f1d36f1;
      hl[4] = 0xade682d1;
      hl[5] = 0x2b3e6c1f;
      hl[6] = 0xfb41bd6b;
      hl[7] = 0x137e2179;

      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;

      for (i = 0; i < n; i++) x[i] = m[b-n+i];
      x[n] = 128;

      n = 256-128*(n<112?1:0);
      x[n-9] = 0;
      ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);

      for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

      return 0;
    }

    function add(p, q) {
      var a = gf(), b = gf(), c = gf(),
          d = gf(), e = gf(), f = gf(),
          g = gf(), h = gf(), t = gf();

      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);

      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }

    function cswap(p, q, b) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }

    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }

    function scalarmult(p, q, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = (s[(i/8)|0] >> (i&7)) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
      }
    }

    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }

    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;

      if (!seeded) randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;

      scalarbase(p, d);
      pack(pk, p);

      for (i = 0; i < 32; i++) sk[i+32] = pk[i];
      return 0;
    }

    var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = (x[j] + 128) >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++) x[j] -= carry * L[j];
      for (i = 0; i < 32; i++) {
        x[i+1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }

    function reduce(r) {
      var x = new Float64Array(64), i;
      for (i = 0; i < 64; i++) x[i] = r[i];
      for (i = 0; i < 64; i++) r[i] = 0;
      modL(r, x);
    }

    // Note: difference from C - smlen returned, not passed as argument.
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];

      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;

      var smlen = n + 64;
      for (i = 0; i < n; i++) sm[64 + i] = m[i];
      for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

      crypto_hash(r, sm.subarray(32), n+32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);

      for (i = 32; i < 64; i++) sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce(h);

      for (i = 0; i < 64; i++) x[i] = 0;
      for (i = 0; i < 32; i++) x[i] = r[i];
      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i+j] += h[i] * d[j];
        }
      }

      modL(sm.subarray(32), x);
      return smlen;
    }

    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(),
          den = gf(), den2 = gf(), den4 = gf(),
          den6 = gf();

      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);

      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);

      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);

      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) M(r[0], r[0], I);

      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) return -1;

      if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

      M(r[3], r[0], r[1]);
      return 0;
    }

    function crypto_sign_open(m, sm, n, pk) {
      var i, mlen;
      var t = new Uint8Array(32), h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()],
          q = [gf(), gf(), gf(), gf()];

      mlen = -1;
      if (n < 64) return -1;

      if (unpackneg(q, pk)) return -1;

      for (i = 0; i < n; i++) m[i] = sm[i];
      for (i = 0; i < 32; i++) m[i+32] = pk[i];
      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q, h);

      scalarbase(q, sm.subarray(32));
      add(p, q);
      pack(t, p);

      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; i++) m[i] = 0;
        return -1;
      }

      for (i = 0; i < n; i++) m[i] = sm[i + 64];
      mlen = n;
      return mlen;
    }

    var crypto_secretbox_KEYBYTES = 32,
        crypto_secretbox_NONCEBYTES = 24,
        crypto_secretbox_ZEROBYTES = 32,
        crypto_secretbox_BOXZEROBYTES = 16,
        crypto_scalarmult_BYTES = 32,
        crypto_scalarmult_SCALARBYTES = 32,
        crypto_box_PUBLICKEYBYTES = 32,
        crypto_box_SECRETKEYBYTES = 32,
        crypto_box_BEFORENMBYTES = 32,
        crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
        crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
        crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
        crypto_sign_BYTES = 64,
        crypto_sign_PUBLICKEYBYTES = 32,
        crypto_sign_SECRETKEYBYTES = 64,
        crypto_sign_SEEDBYTES = 32,
        crypto_hash_BYTES = 64;

    nacl.lowlevel = {
      crypto_core_hsalsa20: crypto_core_hsalsa20,
      crypto_stream_xor: crypto_stream_xor,
      crypto_stream: crypto_stream,
      crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
      crypto_stream_salsa20: crypto_stream_salsa20,
      crypto_onetimeauth: crypto_onetimeauth,
      crypto_onetimeauth_verify: crypto_onetimeauth_verify,
      crypto_verify_16: crypto_verify_16,
      crypto_verify_32: crypto_verify_32,
      crypto_secretbox: crypto_secretbox,
      crypto_secretbox_open: crypto_secretbox_open,
      crypto_scalarmult: crypto_scalarmult,
      crypto_scalarmult_base: crypto_scalarmult_base,
      crypto_box_beforenm: crypto_box_beforenm,
      crypto_box_afternm: crypto_box_afternm,
      crypto_box: crypto_box,
      crypto_box_open: crypto_box_open,
      crypto_box_keypair: crypto_box_keypair,
      crypto_hash: crypto_hash,
      crypto_sign: crypto_sign,
      crypto_sign_keypair: crypto_sign_keypair,
      crypto_sign_open: crypto_sign_open,

      crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES: crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
      crypto_hash_BYTES: crypto_hash_BYTES
    };

    /* High-level API */

    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
      if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
    }

    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
      if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
    }

    function checkArrayTypes() {
      for (var i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError('unexpected type, use Uint8Array');
      }
    }

    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++) arr[i] = 0;
    }

    nacl.randomBytes = function(n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };

    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };

    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32) return null;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };

    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
      if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q, n, p);
      return q;
    };

    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q, n);
      return q;
    };

    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };

    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };

    nacl.box.after = nacl.secretbox;

    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };

    nacl.box.open.after = nacl.secretbox.open;

    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return {publicKey: pk, secretKey: sk};
    };

    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    };

    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;

    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };

    nacl.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error('bad public key size');
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0) return null;
      var m = new Uint8Array(mlen);
      for (var i = 0; i < m.length; i++) m[i] = tmp[i];
      return m;
    };

    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
      return sig;
    };

    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error('bad signature size');
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error('bad public key size');
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
      for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
      return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
    };

    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return {publicKey: pk, secretKey: sk};
    };

    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
      return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    };

    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error('bad seed size');
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++) sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return {publicKey: pk, secretKey: sk};
    };

    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;

    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };

    nacl.hash.hashLength = crypto_hash_BYTES;

    nacl.verify = function(x, y) {
      checkArrayTypes(x, y);
      // Zero length arguments are considered not equal.
      if (x.length === 0 || y.length === 0) return false;
      if (x.length !== y.length) return false;
      return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
    };

    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };

    (function() {
      // Initialize PRNG if environment provides CSPRNG.
      // If not, methods calling randombytes will throw.
      var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
      if (crypto && crypto.getRandomValues) {
        // Browsers.
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) {
            crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0; i < n; i++) x[i] = v[i];
          cleanup(v);
        });
      } else if (typeof commonjsRequire !== 'undefined') {
        // Node.js.
        crypto = require$$0;
        if (crypto && crypto.randomBytes) {
          nacl.setPRNG(function(x, n) {
            var i, v = crypto.randomBytes(n);
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();

    })(module.exports ? module.exports : (self.nacl = self.nacl || {}));
    });

    /**
     * Tweetnacl utility module to provide a consistent import for both node and browsers.
     */
    var nacl = undefined;
    // Browser.
    /* tslint:disable */
    if (typeof window !== 'undefined') {
        // @ts-ignore
        nacl = naclFast;
    }
    // Node.
    else {
        nacl = require('tweetnacl');
    }
    var nacl$1 = nacl;

    function ecdhTweak(peerPublicKey, privateKey) {
        return __awaiter(this, void 0, void 0, function () {
            var boxKDFTweakStr, boxKDFTweak, i, preMasterKey, hash;
            return __generator(this, function (_a) {
                boxKDFTweakStr = 'MRAE_Box_Deoxys-II-256-128';
                boxKDFTweak = new Uint8Array(boxKDFTweakStr.length);
                for (i = 0; i < boxKDFTweakStr.length; i++) {
                    boxKDFTweak[i] = boxKDFTweakStr.charCodeAt(i);
                }
                preMasterKey = nacl$1.scalarMult(privateKey.bytes(), peerPublicKey.bytes());
                hash = require('crypto').createHmac('sha256', boxKDFTweak);
                hash.update(preMasterKey);
                return [2 /*return*/, new Uint8Array(hash.digest())];
            });
        });
    }

    var hmacKey = undefined;
    function ecdhTweak$1(peerPublicKey, privateKey) {
        return __awaiter(this, void 0, void 0, function () {
            var preMasterKey, aesKey, owndAesKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!hmacKey) return [3 /*break*/, 2];
                        return [4 /*yield*/, makeHmacKey()];
                    case 1:
                        hmacKey = _a.sent();
                        _a.label = 2;
                    case 2:
                        preMasterKey = nacl$1.scalarMult(privateKey.bytes(), peerPublicKey.bytes());
                        return [4 /*yield*/, window.crypto.subtle.sign(
                            // @ts-ignore
                            { name: 'HMAC' }, hmacKey, preMasterKey)];
                    case 3:
                        aesKey = _a.sent();
                        owndAesKey = new Uint8Array(aesKey);
                        // Attempt to force references to be dropped since tweetnacl retains ownership
                        // of the underlying array.
                        // @ts-ignore
                        preMasterKey = undefined;
                        aesKey = undefined;
                        return [2 /*return*/, owndAesKey];
                }
            });
        });
    }
    function makeHmacKey() {
        return __awaiter(this, void 0, void 0, function () {
            var boxKDFTweak;
            return __generator(this, function (_a) {
                boxKDFTweak = new TextEncoder().encode('MRAE_Box_Deoxys-II-256-128');
                // @ts-ignore
                return [2 /*return*/, window.crypto.subtle.importKey('raw', boxKDFTweak, {
                        name: 'HMAC',
                        hash: { name: 'SHA-256' },
                    }, false, ['sign'])];
            });
        });
    }

    /**
     * ecdhTweak applies the X25519 scalar multiply with the given public and
     * private keys, and applies a HMAC based tweak to the resulting output.
     *
     * This module supplies two different versions, depending upon whether we're
     * in browser or node.
     */
    // tslint:disable-next-line
    var ecdhTweak$2 = typeof window !== 'undefined' ? ecdhTweak$1 : ecdhTweak;

    var Deoxysii = /** @class */ (function () {
        function Deoxysii() {
        }
        Deoxysii.prototype.seal = function (nonce, plaintext, additionalData, peerPublicKey, privateKey) {
            return __awaiter(this, void 0, void 0, function () {
                var aesKey, aead;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, ecdhTweak$2(peerPublicKey, privateKey)];
                        case 1:
                            aesKey = _a.sent();
                            aead = new deoxysii_7(aesKey);
                            return [2 /*return*/, aead.encrypt(nonce.bytes(), plaintext, additionalData)];
                    }
                });
            });
        };
        Deoxysii.prototype.open = function (nonce, ciphertext, additionalData, peerPublicKey, privateKey) {
            return __awaiter(this, void 0, void 0, function () {
                var aesKey, aead;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, ecdhTweak$2(peerPublicKey, privateKey)];
                        case 1:
                            aesKey = _a.sent();
                            aead = new deoxysii_7(aesKey);
                            return [2 /*return*/, aead.decrypt(nonce.bytes(), ciphertext, additionalData)];
                    }
                });
            });
        };
        Deoxysii.prototype.nonceSize = function () {
            return deoxysii_2;
        };
        Deoxysii.prototype.keySize = function () {
            return deoxysii_1;
        };
        return Deoxysii;
    }());

    var EncryptError = /** @class */ (function (_super) {
        __extends(EncryptError, _super);
        function EncryptError(encParams) {
            var params = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                params[_i - 1] = arguments[_i];
            }
            var _this = _super.apply(this, params) || this;
            _this.encParams = encParams;
            return _this;
        }
        return EncryptError;
    }(Error));
    var KeyStoreError = /** @class */ (function (_super) {
        __extends(KeyStoreError, _super);
        function KeyStoreError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return KeyStoreError;
    }(Error));

    var KeyStore$$1 = /** @class */ (function () {
        function KeyStore$$1(db, keyProvider) {
            this.db = db;
            this.keyProvider = keyProvider;
        }
        /**
         * @returns the public key for the given service.
         */
        KeyStore$$1.prototype.publicKey = function (service) {
            return __awaiter(this, void 0, void 0, function () {
                var key;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            key = this.getCachedPublicKey(service);
                            if (key) {
                                return [2 /*return*/, key];
                            }
                            return [4 /*yield*/, this.getRequestPublicKey(service)];
                        case 1:
                            // Make a request to the keyProvider for the key.
                            key = _a.sent();
                            // Cache the key.
                            this.setCachedPublicKey(service, key);
                            return [2 /*return*/, key];
                    }
                });
            });
        };
        /**
         * @returns the cached public key if it exists.
         */
        KeyStore$$1.prototype.getCachedPublicKey = function (service) {
            service = typeof service === 'string' ? service : bytes.toHex(service);
            var key = this.db.get(service);
            if (!key) {
                return undefined;
            }
            // todo: re-enable caching: https://github.com/oasislabs/oasis.js/issues/150
            // return new PublicKey(bytes.parseHex(key));
            return undefined;
        };
        /**
         * Saves the public key in the cache.
         */
        KeyStore$$1.prototype.setCachedPublicKey = function (service, publicKey) {
            service = typeof service === 'string' ? service : bytes.toHex(service);
            var value = bytes.toHex(publicKey.bytes());
            this.db.set(service, value);
        };
        /**
         * Makes a request to the keyProvider for the public key for the given service.
         */
        KeyStore$$1.prototype.getRequestPublicKey = function (service) {
            return __awaiter(this, void 0, void 0, function () {
                var response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // Ensure we are using Uint8Array.
                            service = typeof service !== 'string' ? service : bytes.parseHex(service);
                            return [4 /*yield*/, this.keyProvider.publicKey({ address: service })];
                        case 1:
                            response = _a.sent();
                            if (!response.publicKey) {
                                throw new KeyStoreError("KeyProvider did not return a public key: " + response);
                            }
                            return [2 /*return*/, new PublicKey(response.publicKey)];
                    }
                });
            });
        };
        /**
         * @returns the local keys specific to this user (not a Service). If they don't exist,
         *          create them.
         */
        KeyStore$$1.prototype.localKeys = function () {
            var serializedKeys = this.db.get(KeyStore$$1.LOCAL_KEYPAIR_KEY);
            if (serializedKeys) {
                return KeyStore$$1.deserializeKeyPair(serializedKeys);
            }
            var keyPair = this.newKeyPair();
            this.db.set(KeyStore$$1.LOCAL_KEYPAIR_KEY, KeyStore$$1.serializeKeyPair(keyPair));
            return keyPair;
        };
        KeyStore$$1.prototype.newKeyPair = function () {
            var kp = nacl$1.box.keyPair();
            return {
                publicKey: new PublicKey(kp.publicKey),
                privateKey: new PrivateKey(kp.secretKey),
            };
        };
        KeyStore$$1.serializeKeyPair = function (keyPair) {
            return JSON.stringify({
                publicKey: bytes.toHex(keyPair.publicKey.bytes()),
                privateKey: bytes.toHex(keyPair.privateKey.bytes()),
            });
        };
        KeyStore$$1.deserializeKeyPair = function (keyPair) {
            var kp = JSON.parse(keyPair);
            return {
                publicKey: new PublicKey(bytes.parseHex(kp.publicKey)),
                privateKey: new PrivateKey(bytes.parseHex(kp.privateKey)),
            };
        };
        /**
         * LOCAL_KEYS is the db key where the local keypair is stored.
         */
        KeyStore$$1.LOCAL_KEYPAIR_KEY = '@oasislabs/client/me';
        return KeyStore$$1;
    }());

    var aead = new Deoxysii();
    /**
     * Expected number of bytes of the CIPHER_LENGTH field of the ciphertext layout.
     */
    var CIPHER_LEN_SIZE = 8;
    /**
     * Expected number of bytes of the AAD_LENGTH field of the ciphertext layout.
     */
    var AAD_LEN_SIZE = 8;
    /**
     * encrypt takes the given input and returns the encrypted wire format:
     * PUBLIC_KEY || CIPHER_LENGTH || AAD_LENGTH || CIPHER || AAD || NONCE
     * where CIPHER_LENGTH and AAD_LENGTH are encoded big endian uint64
     */
    function encrypt(nonce, plaintext, peerPublicKey, publicKey, privateKey, aad) {
        return __awaiter(this, void 0, void 0, function () {
            var ciphertext;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, aead.seal(nonce, plaintext, aad, peerPublicKey, privateKey)];
                    case 1:
                        ciphertext = _a.sent();
                        if (ciphertext.length > Number.MAX_SAFE_INTEGER ||
                            aad.length > Number.MAX_SAFE_INTEGER) {
                            throw new EncryptError({
                                nonce: nonce,
                                ciphertext: ciphertext,
                                peerPublicKey: peerPublicKey,
                                publicKey: publicKey,
                                aad: aad,
                            }, 'ciphertext or aad may not exceed 2^53-1');
                        }
                        return [2 /*return*/, bytes.concat([
                                publicKey.bytes(),
                                bytes.parseNumber(ciphertext.length, CIPHER_LEN_SIZE, true),
                                bytes.parseNumber(aad.length, AAD_LEN_SIZE, true),
                                ciphertext,
                                aad,
                                nonce.bytes(),
                            ])];
                }
            });
        });
    }
    /**
     * decrypt takes the given input and returns the unpacked Decryption payload.
     *
     * @param ciphertext is of the form NONCE || PUBLIC_KEY || CIPHER.
     */
    function decrypt(encryption, secretKey) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, peerPublicKey, ciphertext, aad, nonce, plaintext;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = splitEncryptedPayload(encryption), peerPublicKey = _a[0], ciphertext = _a[1], aad = _a[2], nonce = _a[3];
                        if (ciphertext.length > Number.MAX_SAFE_INTEGER ||
                            aad.length > Number.MAX_SAFE_INTEGER) {
                            throw new EncryptError({
                                nonce: nonce,
                                ciphertext: ciphertext,
                                peerPublicKey: peerPublicKey,
                                aad: aad,
                            }, 'ciphertext or aad may not exceed 2^53-1');
                        }
                        return [4 /*yield*/, aead.open(nonce, ciphertext, aad, peerPublicKey, secretKey)];
                    case 1:
                        plaintext = _b.sent();
                        return [2 /*return*/, {
                                nonce: nonce,
                                plaintext: plaintext,
                                peerPublicKey: peerPublicKey,
                                aad: aad,
                            }];
                }
            });
        });
    }
    function nonce() {
        return new Nonce(nacl$1.randomBytes(aead.nonceSize()));
    }
    /**
     * Splits the given ciphertext into it's constituent components.
     *
     * @param ciphertext is of the form:
     *        PUBLIC_KEY || CIPHER_LENGTH || AAD_LENGTH || CIPHER || AAD || NONCE
     *        where CIPHER_LENGTH and AAD_LENGTH are encoded big endian uint64
     */
    function splitEncryptedPayload(encryption) {
        if (encryption.length < ciphertextSize(0, 0)) {
            throw new Error("ciphertext is too short: " + encryption);
        }
        var nonce = new Uint8Array(aead.nonceSize());
        var publicKey = new Uint8Array(aead.keySize());
        var cipherLengthOffset = aead.keySize();
        var aadLengthOffset = cipherLengthOffset + CIPHER_LEN_SIZE;
        var cipherOffset = aadLengthOffset + AAD_LEN_SIZE;
        publicKey.set(encryption.slice(0, publicKey.length));
        var cipherLength = bytes.toNumber(encryption.slice(cipherLengthOffset, cipherLengthOffset + CIPHER_LEN_SIZE), true);
        var aadLength = bytes.toNumber(encryption.slice(aadLengthOffset, aadLengthOffset + AAD_LEN_SIZE), true);
        if (encryption.length !== ciphertextSize(cipherLength, aadLength)) {
            throw new Error("invalid ciphertext lenghth: " + encryption);
        }
        var ciphertext = new Uint8Array(cipherLength);
        ciphertext.set(encryption.slice(cipherOffset, cipherOffset + cipherLength));
        var aad = encryption.slice(cipherOffset + cipherLength, cipherOffset + cipherLength + aadLength);
        nonce.set(encryption.slice(cipherOffset + cipherLength + aadLength));
        return [new PublicKey(publicKey), ciphertext, aad, new Nonce(nonce)];
    }
    function ciphertextSize(cipherLen, aadLen) {
        return (aead.keySize() +
            CIPHER_LEN_SIZE +
            AAD_LEN_SIZE +
            cipherLen +
            aadLen +
            aead.nonceSize());
    }
    var PublicKey = /** @class */ (function () {
        function PublicKey(inner) {
            this.inner = bytes.assertLength(inner, aead.keySize());
        }
        PublicKey.prototype.bytes = function () {
            return this.inner;
        };
        return PublicKey;
    }());
    var PrivateKey = /** @class */ (function () {
        function PrivateKey(inner) {
            this.inner = bytes.assertLength(inner, aead.keySize());
        }
        PrivateKey.prototype.bytes = function () {
            return this.inner;
        };
        return PrivateKey;
    }());
    var Nonce = /** @class */ (function () {
        function Nonce(inner) {
            this.inner = bytes.assertLength(inner, aead.nonceSize());
        }
        Nonce.prototype.bytes = function () {
            return this.inner;
        };
        return Nonce;
    }());

    exports.splitEncryptedPayload = splitEncryptedPayload;
    exports.PublicKey = PublicKey;
    exports.PrivateKey = PrivateKey;
    exports.Nonce = Nonce;
    exports.encrypt = encrypt;
    exports.decrypt = decrypt;
    exports.nonce = nonce;
    exports.Deoxysii = Deoxysii;
    exports.KeyStore = KeyStore$$1;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.browser.umd.js.map
