export declare type DeployHeaderOptions = {
    expiry?: number;
    confidential?: boolean;
};
export declare class DeployHeaderError extends Error {
}
export declare class DeployHeader {
    version: number;
    body: DeployHeaderOptions;
    /**
     * @param {Number} version is the header version number.
     * @param {Object} is the header body with two fields, expiry (Number)
     *        and confidential (boolean).
     */
    constructor(version: number, body: DeployHeaderOptions);
    data(): Uint8Array;
    /**
     * @param   {Object} headerBody is the header object to encode.
     * @param   {Uint8Array} deploycode is the bytecode to which we want to prefix the header.
     * @returns The deploycode with the header prefixed as the encoded wire format, i.e.,
     *          b'\0sis' || version (2 bytes big endian) || length (2 bytes big endian) || json-header.
     *          Overrides any header fields that may already exist in the deploycode.
     */
    static deployCode(headerBody: DeployHeaderOptions, deploycode: Uint8Array): Uint8Array;
    private static deployCodePreconditions;
    /**
     * @returns true iff the keys in the headerBody are part of the valid set.
     */
    static isValidBody(headerBody: DeployHeaderOptions): boolean;
    /**
     * Returns the current version of the header.
     */
    static currentVersion(): number;
    static prefix(): Uint8Array;
}
/**
 * A collection of utilities for parsing through deploycode including the Oasis contract
 * deploy header in the form of a hex string.
 */
export declare class DeployHeaderReader {
    /**
     * @param   {String} deploycode is the transaction data to deploy a contract as a hex string.
     * @returns the contract deploy header prefixed to the deploycode, otherwise, null.
     */
    static header(deploycode: Uint8Array): DeployHeader | null;
    /**
     * @param {Uint8Array} deploycode is a hex string of the header || initcode.
     */
    static body(deploycode: Uint8Array): DeployHeaderOptions;
    /**
     * @param {String} deploycode is a hex string of the header || initcode.
     */
    static size(deploycode: Uint8Array): number;
    /**
     * @param {String} deploycode is a hex string of the header || initcode.
     */
    static version(deploycode: Uint8Array): number;
    /**
     * @param {String} deploycode is a hex string of the header || initcode.
     */
    static initcode(deploycode: Uint8Array): Uint8Array;
    private static initcodeStart;
    /**
     * @param {Uint8Array} the 2-byte representation of the input.
     * @returns {Number} an unsigned 16-bit number.
     */
    static shortFromBytes(arr: Uint8Array): number;
    static codeHasPrefixPrefix(code: Uint8Array): boolean;
    /**
     * @returns the hex string index of the start section.
     */
    private static versionStart;
    /**
     * @returns the length of the version in bytes.
     */
    static versionLength(): number;
    /**
     * @returns the index of the starting point of the size section.
     */
    private static sizeStart;
    /**
     * @returns the length of the body size in bytes.
     */
    private static sizeLength;
    /**
     * @returns the hex string index of the body section.
     */
    private static bodyStart;
}
export declare class DeployHeaderWriter {
    static body(body: DeployHeaderOptions): Uint8Array;
    /**
     * @param {Number} an unsigned 16-bit number.
     * @returns {Uint8Array} the 2-byte representation of the input.
     */
    static shortToBytes(num: number): Uint8Array;
}
declare function parseFromCode(deploycode: Uint8Array | string): DeployHeader | null;
export declare const header: {
    parseFromCode: typeof parseFromCode;
    deployCode: typeof DeployHeader.deployCode;
};
export {};
