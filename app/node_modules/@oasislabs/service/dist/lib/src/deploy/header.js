var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { bytes } from '@oasislabs/common';
var DeployHeaderError = /** @class */ (function (_super) {
    __extends(DeployHeaderError, _super);
    function DeployHeaderError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DeployHeaderError;
}(Error));
export { DeployHeaderError };
// TODO: change all apis here to take Uint8Arrays as input/output instead
//       of hex strings.
var DeployHeader = /** @class */ (function () {
    /**
     * @param {Number} version is the header version number.
     * @param {Object} is the header body with two fields, expiry (Number)
     *        and confidential (boolean).
     */
    function DeployHeader(version, body) {
        this.version = version;
        this.body = body;
    }
    DeployHeader.prototype.data = function () {
        var bodyBytes = DeployHeaderWriter.body(this.body);
        return new Uint8Array(bytes.concat([
            DeployHeader.prefix(),
            DeployHeaderWriter.shortToBytes(this.version),
            DeployHeaderWriter.shortToBytes(bodyBytes.length),
            bodyBytes,
        ]));
    };
    /**
     * @param   {Object} headerBody is the header object to encode.
     * @param   {Uint8Array} deploycode is the bytecode to which we want to prefix the header.
     * @returns The deploycode with the header prefixed as the encoded wire format, i.e.,
     *          b'\0sis' || version (2 bytes big endian) || length (2 bytes big endian) || json-header.
     *          Overrides any header fields that may already exist in the deploycode.
     */
    DeployHeader.deployCode = function (headerBody, deploycode) {
        DeployHeader.deployCodePreconditions(headerBody, deploycode);
        if (Object.keys(headerBody).length === 0) {
            return deploycode; // No header, so do nothing.
        }
        // Read the existing header, if it exists.
        var currentHeader = DeployHeaderReader.header(deploycode);
        // Bytecode to create the contract without the serialized deploy header prepended.
        var initcode;
        // No header so just make a new one. The initcode is the given deploycode.
        if (currentHeader === null) {
            currentHeader = new DeployHeader(DeployHeader.currentVersion(), {});
            initcode = deploycode;
        }
        // Extract the initcode from the deploy code.
        else {
            initcode = DeployHeaderReader.initcode(deploycode);
        }
        if (headerBody) {
            Object.assign(currentHeader.body, headerBody);
        }
        var headerData = currentHeader.data();
        var code = new Uint8Array(headerData.length + initcode.length);
        code.set(headerData);
        code.set(initcode, headerData.length);
        return code;
    };
    DeployHeader.deployCodePreconditions = function (headerBody, deploycode) {
        if (!headerBody) {
            throw new Error('No header given');
        }
        if (deploycode.length === 0) {
            throw new Error('Malformed deploycode');
        }
        if (!DeployHeader.isValidBody(headerBody)) {
            throw new Error('Malformed deploycode or header');
        }
    };
    /**
     * @returns true iff the keys in the headerBody are part of the valid set.
     */
    DeployHeader.isValidBody = function (headerBody) {
        var validKeys = ['expiry', 'confidential'];
        var keys = Object.keys(headerBody);
        for (var k = 0; k < keys.length; k += 1) {
            if (!validKeys.includes(keys[k])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Returns the current version of the header.
     */
    DeployHeader.currentVersion = function () {
        return 1;
    };
    DeployHeader.prefix = function () {
        return bytes.encodeUtf8('\0sis');
    };
    return DeployHeader;
}());
export { DeployHeader };
/**
 * A collection of utilities for parsing through deploycode including the Oasis contract
 * deploy header in the form of a hex string.
 */
var DeployHeaderReader = /** @class */ (function () {
    function DeployHeaderReader() {
    }
    /**
     * @param   {String} deploycode is the transaction data to deploy a contract as a hex string.
     * @returns the contract deploy header prefixed to the deploycode, otherwise, null.
     */
    DeployHeaderReader.header = function (deploycode) {
        if (!DeployHeaderReader.codeHasPrefixPrefix(deploycode)) {
            return null;
        }
        var version = DeployHeaderReader.version(deploycode);
        var body = DeployHeaderReader.body(deploycode);
        if (!DeployHeader.isValidBody(body)) {
            throw Error("Invalid body " + JSON.stringify(body));
        }
        return new DeployHeader(version, body);
    };
    /**
     * @param {Uint8Array} deploycode is a hex string of the header || initcode.
     */
    DeployHeaderReader.body = function (deploycode) {
        if (!DeployHeaderReader.codeHasPrefixPrefix(deploycode)) {
            throw new DeployHeaderError('code must have the header prefiix');
        }
        var length = DeployHeaderReader.size(deploycode);
        var serializedBody = deploycode.subarray(DeployHeaderReader.bodyStart(), DeployHeaderReader.bodyStart() + length);
        return JSON.parse(bytes.decodeUtf8(serializedBody));
    };
    /**
     * @param {String} deploycode is a hex string of the header || initcode.
     */
    DeployHeaderReader.size = function (deploycode) {
        if (!DeployHeaderReader.codeHasPrefixPrefix(deploycode)) {
            throw new DeployHeaderError('code must have the header prefix');
        }
        var start = DeployHeaderReader.sizeStart();
        var lengthBytes = deploycode.subarray(start, start + DeployHeaderReader.sizeLength());
        return DeployHeaderReader.shortFromBytes(lengthBytes);
    };
    /**
     * @param {String} deploycode is a hex string of the header || initcode.
     */
    DeployHeaderReader.version = function (deploycode) {
        if (!DeployHeaderReader.codeHasPrefixPrefix(deploycode)) {
            throw new DeployHeaderError('code must have the header prefix');
        }
        var start = DeployHeaderReader.versionStart();
        var versionBytes = deploycode.subarray(start, start + DeployHeaderReader.versionLength());
        return DeployHeaderReader.shortFromBytes(versionBytes);
    };
    /**
     * @param {String} deploycode is a hex string of the header || initcode.
     */
    DeployHeaderReader.initcode = function (deploycode) {
        if (!DeployHeaderReader.codeHasPrefixPrefix(deploycode)) {
            throw new DeployHeaderError('code must have the header prefix');
        }
        return deploycode.subarray(DeployHeaderReader.initcodeStart(deploycode));
    };
    DeployHeaderReader.initcodeStart = function (deploycode) {
        if (!DeployHeaderReader.codeHasPrefixPrefix(deploycode)) {
            throw new DeployHeaderError('code must have the header prefix');
        }
        return DeployHeaderReader.bodyStart() + DeployHeaderReader.size(deploycode);
    };
    /**
     * @param {Uint8Array} the 2-byte representation of the input.
     * @returns {Number} an unsigned 16-bit number.
     */
    DeployHeaderReader.shortFromBytes = function (arr) {
        return new DataView(arr.buffer).getUint16(arr.byteOffset, false /* little endian */);
    };
    DeployHeaderReader.codeHasPrefixPrefix = function (code) {
        var prefix = DeployHeader.prefix();
        for (var i = 0; i < prefix.length; i++) {
            if (code[i] !== prefix[i]) {
                return false;
            }
        }
        return true;
    };
    /**
     * @returns the hex string index of the start section.
     */
    DeployHeaderReader.versionStart = function () {
        return DeployHeader.prefix().length;
    };
    /**
     * @returns the length of the version in bytes.
     */
    DeployHeaderReader.versionLength = function () {
        return 2;
    };
    /**
     * @returns the index of the starting point of the size section.
     */
    DeployHeaderReader.sizeStart = function () {
        return (DeployHeaderReader.versionStart() + DeployHeaderReader.versionLength());
    };
    /**
     * @returns the length of the body size in bytes.
     */
    DeployHeaderReader.sizeLength = function () {
        return 2;
    };
    /**
     * @returns the hex string index of the body section.
     */
    DeployHeaderReader.bodyStart = function () {
        return DeployHeaderReader.sizeStart() + DeployHeaderReader.sizeLength();
    };
    return DeployHeaderReader;
}());
export { DeployHeaderReader };
var DeployHeaderWriter = /** @class */ (function () {
    function DeployHeaderWriter() {
    }
    DeployHeaderWriter.body = function (body) {
        return bytes.encodeUtf8(JSON.stringify(body));
    };
    /**
     * @param {Number} an unsigned 16-bit number.
     * @returns {Uint8Array} the 2-byte representation of the input.
     */
    DeployHeaderWriter.shortToBytes = function (num) {
        var arr = new Uint8Array(2);
        new DataView(arr.buffer).setUint16(0 /* offset */, num, false /* little endian */);
        return arr;
    };
    return DeployHeaderWriter;
}());
export { DeployHeaderWriter };
// Alias.
function parseFromCode(deploycode) {
    var _deploycode = typeof deploycode === 'string' ? bytes.parseHex(deploycode) : deploycode;
    return DeployHeaderReader.header(_deploycode);
}
// Convenience api export.
export var header = {
    parseFromCode: parseFromCode,
    deployCode: DeployHeader.deployCode,
};
//# sourceMappingURL=header.js.map